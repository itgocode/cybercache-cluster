.\" Automatically generated by Pandoc 2.5
.\"
.ad l
.TH "cybercache" "1" "October 29, 2021" "Copyright (C) 2019 CyberHULL" "CyberCache CE 1.3.6 Configuration"
.hy
.SH CyberCache Server Configuration
.PP
This manual describes overall structure of CyberCache server\[cq]s configuration files, as well as format, meanings, and allowed values of individual options.
.SS Configuration File Locations
.PP
Default CyberCache configuration file resides in the \f[C]/etc/cybercache\f[R] directory and is named \f[C]cybercached.cfg\f[R] or, alternatively, it can be put into the same directory with the \f[C]cybercached\f[R] executable \[en] if it is to be loaded automatically.
Alternatively, full path to configuration file can be specified as the very last command line argument to \f[C]cybercached\f[R], after all options; if specified path starts with `.' or `/', it will be used \[lq]as is\[rq], otherwise, CyberCache with search stardard locations (\f[C]/etc/\f[R] and executable file\[cq]s directory) for it.
.SS Configuration File Format
.PP
General format of all configuration statements is
.IP
.nf
\f[C]
<statement> <value1> [<value2> [...]]
\f[R]
.fi
.PP
where \f[C]<value>\f[R] can be a reserved word, an integer (up to 64\-bit) or floating point number, or a string in optional single (normal or back) quotes, or double quotes; quotation marks are necessary if the string contains spaces or escape characters; within a quoted string, the following escape sequences are recognized and converted to characters (note that it is only necessary to escape a quotation mark within a string that is delimited with that \f[I]same\f[R] quotation mark):
.IP \[bu] 2
\f[C]\[rs]\[rs]\f[R] : backslash,
.IP \[bu] 2
\f[C]\[rs]xx\f[R] : character with hexadecimal code \f[C]xx\f[R] (in upper or lower case),
.IP \[bu] 2
\f[C]\[rs]r\f[R] : carriage return,
.IP \[bu] 2
\f[C]\[rs]n\f[R] : line feed (new line),
.IP \[bu] 2
\f[C]\[rs]t\f[R] : tabulation (tab character),
.IP \[bu] 2
\f[C]\[rs]\[aq]\f[R] : apostrophe (single quote),
.IP \[bu] 2
\[ga]\[ga]\[ga] : backtick (back quote / grave accent),
.IP \[bu] 2
\f[C]\[rs]\[dq]\f[R] : double quote.
.PP
Other common escape sequences (such as \f[C]\[rs]a\f[R] for beep, \f[C]\[rs]b\f[R] for backspace, or for \f[C]\[rs]f\f[R] form feed) are not supported as they would interfere with hexadecimal codes; a single quote do not have to be escaped within double\-quoted string, and vice versa).
.PP
Hash mark in any position \f[I]except\f[R] inside a quoted string starts comment; backslash as the very last character on the line means that the option will be continued on the next line (carried over).
.PP
An integer number can be prefixed with \f[C]0\f[R] or \f[C]0x\f[R] to specify octal or hexadecimal notation, respectively.
If indeger number is used to specify memory or file size, it can be followed by a suffix, with \f[C]b\f[R] standing for bytes, \f[C]k\f[R] for kilobytes, \f[C]m\f[R] for megabytes, \f[C]g\f[R] for gigabytes, \f[C]t\f[R] for terabytes; lack of suffix means bytes.
Likewise, whenever a duration is required, the number can be followed by \f[C]s\f[R] (seconds), \f[C]m\f[R] (minutes), \f[C]h\f[R] (hours), \f[C]d\f[R] (days), or \f[C]w\f[R] (weeks) suffixes; lack of suffix means seconds.
Even if size is specified in bytes, or duration is seconds (so suffixes are optional), we advise to use suffixes anyway (\f[C]b\f[R] and \f[C]s\f[R], respectively) to avoid ambiguity.
Letters in both prefixes and suffixes can be in either lower or upper case.
.RS
.PP
\f[B]IMPORTANT\f[R]: whenever an option documentation refers to a \f[C]<size>\f[R] argument, it means 64\-bit unsigned integer with an optional \f[C]b\f[R], \f[C]k\f[R], \f[C]m\f[R], \f[C]g\f[R], or \f[C]t\f[R] suffix.
Likewise, a reference to argument means 32\-bit unsigned integer with an optional \f[C]s\f[R], \f[C]m\f[R], \f[C]h\f[R], \f[C]d\f[R], or \f[C]w\f[R] suffix.
.RE
.PP
Booleans can be specified using reserved words \f[C]true\f[R], \f[C]yes\f[R], \f[C]on\f[R], \f[C]false\f[R], \f[C]no\f[R], and \f[C]off\f[R].
.PP
Strings starting with digits (such as IP addresses) can still be specified without quotes; in the same vein, numbers can be specified \f[I]with\f[R] quotes, although that is clearly not recommended: one should use discretion and not cause unnecessary confusion.
.PP
Option names (both full and one\-letter shortcuts; see below) are all case\-sensitive, while other reserved words are not.
For instance, \f[C]true\f[R], \f[C]True\f[R], and \f[C]TRUE\f[R] are all valid boolean values (and, as a matter of fact, so are \f[C]TrUe\f[R] and \f[C]truE\f[R], but we very strongly advise against usint them\&...)
.PP
The above\-described format essentially matches the one of the server console.
.SS Server Options as Command Line Arguments
.PP
Any option can also be set using command line argument: it has to be prefixed with \f[C]\-\-\f[R] (double hyphens), underscores in the name can (but do not have to) be replaced with hyphens, and option value must be separated from the name using equal sign.
Additionally, if the option is multi\-value, spaces between values must be replaced with commas.
For instance, configuration option
.IP
.nf
\f[C]
fpc_optimization_compressors gzip zstd
\f[R]
.fi
.PP
can be represented with command line argument
.IP
.nf
\f[C]
\-\-fpc\-optimization\-compressors=gzip,zstd        OR
\-\-fpc_optimization_compressors=gzip,zstd
\f[R]
.fi
.PP
Some configuration options can be specified as one\-letter \f[I]command line\f[R] arguments (i.e.\ short forms \f[I]cannot\f[R] be used in configuration files); the following aliases are currently supported (note that colons must be used instead of equal signs as argument separators):
.IP
.nf
\f[C]
\-\-include=<path>                          ==>  \-i:<path>
\-\-log\-level=<level>                       ==>  \-l:<level>
\-\-num\-connection\-threads=<number>         ==>  \-n:<number>
\-\-max\-memory=<size>                       ==>  \-m:<size>
\-\-max\-session\-memory <size>               ==>  \-s:<size>
\-\-max\-fpc\-memory=<size>                   ==>  \-f:<size>
\-\-listener\-addresses=<address>,<address>  ==>  \-a:<address>,<address>
\-\-listener\-port=<number>                  ==>  \-p:<number>
\f[R]
.fi
.PP
Options specified on the command line always take precedense over their counterparts in the main configuration file (i.e.\ the one specified as the very last argument to \f[C]cybercached\f[R] executable, or, if none was specified, the default one).
Therefore, configuration file loaded using \f[C]\-i\f[R]/\f[C]\-\-include\f[R] option will overwrite settings made by the main configuration file.
The only exception to this rule is log level (\f[C]\-l\f[R]/\f[C]\-\-log\-level\f[R]) option: it takes effect immediately.
.SS Changing Options at Run Time
.PP
Configuration file can be [re]loaded at run time using \f[C]LOCALONFIG [<path>]\f[R] and \f[C]REMOTECONFIG [<path>]\f[R] console commands.
How exactly a particular configuration statements in the newly loaded file will affect running daemon is specified in the documentation to those statements later in this file.
As a general rule, a new option value from a configuration file loaded \f[I]at run time\f[R] takes effect immediately, with only few exceptions, namely:
.IP
.nf
\f[C]
user_password,
admin_password,
bulk_password,
table_hash_method,
password_hash_method,
session_tables_per_store,
fpc_tables_per_store,
tags_tables_per_store,
perf_num_internal_tag_refs
\f[R]
.fi
.PP
The first three are permanent for the session mainly for security reasons; \f[C]password_hash_method\f[R] is permanent because it affects passwords; \f[C]table_hash_method\f[R] \[en] because, if changed, it would invalidate all objects in all tables; \f[C]xxx_tables_per_store\f[R] would basically stall the server for a considerable time (so it can be said that if you could afford changing those options, you\[cq]d just as well afford re\-starting the server); \f[C]perf_num_internal_tag_refs\f[R] would invalidate entire FPC object store.
So values of these nine options can only be set in the very first configuration file loaded by the server, or through command line arguments.
.PP
Additionally, any option except the above\-listed six can be set at run time using console\[cq]s \f[C]SET\f[R] command; there are few options that only affect \f[I]initial\f[R] server state (e.g.\ \f[C]perf_session_init_table_capacity\f[R]), attempts to change them via \f[C]SET\f[R] will be silently ignored.
.PP
   *   *   *   *   *
.SS Options \- Memory Quotas
.PP
Memory quotas are \f[B]the\f[R] most important options of CyberCache affecting its overall performance.
The three available memory quotas are interconnected in that if, say, global (total memory available to CyberCache) quota is set to N bytes, session memory is set to NS bytes, and FPC memory is set to 0 bytes, then the amount of memory that can be used by FPC store will be N minus \f[I]actual\f[R] amount currently used by session store, but not less than N\-NS bytes.
Note that FPC store would be able to use more than N\-NS bytes \[en] but only if session store underutilizes its quota.
Setting global quota (\f[C]max_memory\f[R]), along with store\-specific quota, to zero is also possible, but that would require expiration\-based eviction mode (see below) and is generally less efficient: with properly configured memory quotas, the server will do memory deallocations in specialized optimization threads, concurrently with serving incoming requests, as well as other activities\&... whereas with zero memory quotas, it will run out of memory, interrupt current operation, reclaim some memory, and ony then resume servicing a request.
.PP
Setting store\[cq]s own memory quota always takes precendence.
For instance, setting, say, \f[C]max_memory\f[R] to 16M, \f[C]max_session_memory\f[R] to 4M, and \f[C]max_fpc_memory\f[R] to 8M does not make sense: total used memory will stay around 12M (4M+8M).
Even though the server does do some memory allocations on its own, they are negligible compared to those of session and FPC stores.
Speaking of \[lq]will stay around\&...\[rq]: the server can (and most likely will) allocate memory above its global quota, and only then will start deallocating memory to get below its specified limit.
For this reason, it is advised that global memory quota is never set to anything above 90..95% of the total available physical memory even if CyberCache runs on a dedicated server (for small boxes with 4G or so RAM it should even be less, around 80..85%).
Upon startup, CyberCache server compares specified quotas to the actually available RAM and will log a warning if it is misconfigured, but will proceed with specified quotas nonetheless.
.RS
.PP
\f[B]IMPORTANT\f[R]: the above description clearly shows that the default global quota of 0b is by no means optimal for the server.
The very first thing that system administrator rolling out CyberCache should do is set meaningful global and per\-store memory quotas.
It would be trivial to implement auto\-configuration based on the amount of installed RAM but, after careful consideration it\[cq]s been decided not to do so, because it would give false impression of optimal setup, whereas there\[cq]s no way of taking into account everything that you know about your system (other programs running on the same box, relative importance of session and FPC stores, and the likes).
.PP
On the other hand, setting \f[I]one\f[R] of the store\-specific quotas to zero is, in fact, preferred: it prevents memory from being underutilized.
If the server is used as \f[I]both\f[R] session store and full page cache, then recommended way of configuring the server would be to a) set \f[C]max_memory\f[R] as explained above, b) figure out how many sessions it is necessary to keep (roughly based on the number of unique users for the period during which the sessions should be kept), c) calculate how much memory is needed for them (the instrumented version of CyberCach can help with that), d) set \f[C]max_session_memory\f[R] to calculated amount, e) set \f[C]max_fpc_memory\f[R] to zero.
.RE
.PP
Irrespecive of the amout or available physical RAM, CyberCache server imposes its own limits on the memory quotas that can be specified in the configuration: Community Edition is limited to 32 gigabytes (both total and/or per\-store), while Enterprise Edition is limited to 128 terabytes.
.SS Option format:
.IP \[bu] 2
\f[C]max_memory <size>\f[R]
.IP \[bu] 2
\f[C]max_session_memory <size>\f[R]
.IP \[bu] 2
\f[C]max_fpc_memory <size>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]max_memory 0b\f[R]
.IP \[bu] 2
\f[C]max_session_memory 0b\f[R]
.IP \[bu] 2
\f[C]max_fpc_memory 0b\f[R]
.SS Options \- Server Interface
.PP
The \f[C]listener_xxx\f[R] options specify what IP address/port combinations the server will be listening to, waiting for incoming requests.
.PP
It is possible to specify multiple addresses, but not the port.
In case of multiple addresses, they should \f[I]all\f[R] be specified using a single statement; if they do not fit one line, line continuation (backslash at the very end of the string) should be used.
Multiple \f[C]listener_addresses\f[R] and/or \f[C]listener_port\f[R] statements will \f[I]not\f[R] specify multiple sockets; instead, last found statement overwrites all previous.
.PP
The addresses to listen to can be specified as numeric IPs (e.g.\ \f[C]127.0.0.1\f[R]), of as domain names (e.g.\ \f[C]localhost\f[R] or \f[C]cybercache.example.com\f[R]); the cache will resolve them into IPs.
Note that there is no default address(es): it is entirely possible to start CyberCache server w/o specifying an address in either configuration file, or command line.
In such a case, the server will wait for a \f[C]SET\f[R] command (e.g.\ sent using console) that would specify address(es) and/or port for it to listen to, and will start listening as soon as it receives such a command.
It is also possible to use \f[C]SET\f[R] to reconfigure address(es) and/or port of an already running/listening server.
.PP
Different editions have different limits on the number of addresses that the server can simultaneously listen to: Community Edition supports up to two addresses, while Enterprise Edition supports up to 16.
.PP
Default port number is 8120.
It is possible to specify another port, as long as it is in 1024..65535 range, and does not conflict with other services.
If in doubt if a partcular port is safe to use, search IANA for that port number: http://www.iana.org/assignments/service\-names\-port\-numbers/service\-names\-port\-numbers.xhtml?search=
.SS Option format:
.IP \[bu] 2
\f[C]listener_addresses <address> [<address> [...]]\f[R]
.IP \[bu] 2
\f[C]listener_port <number>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]listener_addresses 0 (NO DEFAULT)\f[R]
.IP \[bu] 2
\f[C]listener_port 8120\f[R]
.SS Options \- Connection Types
.PP
CyberCache Cluster can work in two modes: per\-command connections, and persistent connections.
The former makes CyberCache open connection upon receiving a command, and close it upon sending a response; the latter differs in that CyberCache never closes a connection itself: it waits for a client to do so.
Persistent connections provide a welcome performance boost for typical use cases; for instance, Magento sends dozens of commands while processing a single page request, so with persistent connections the connection between PHP extension and CyberCache will be closed (by PHP extension) only upon finishing processing the request.
Hence connections are persistent by default, and not only in the server, but also in all clients (console, PHP extension, Magento 1 and 2 extensions) shipped as part of the CyberCache Cluster package.
.PP
\f[B]IMPORTANT\f[R]: If CyberCache server and its client use different types of connections (say, the the serer is in persistent connections mode, while the console is configured to use per\-command connections), they should still be able to work together; however, in such a case reliable communication is \f[I]not guaranteed\f[R].
So it is highly advisable to make sure every client/server pair uses the same connection type; namely:
.IP \[bu] 2
If main server has \f[C]session_replicator_persistent\f[R] set to \f[C]true\f[R], then server used for session replication has to have \f[C]listener_persistent\f[R] set to \f[C]true\f[R] as well; likewise, if main server has \f[C]fpc_replicator_persistent\f[R] set to \f[C]true\f[R], then server used for FPC replication should have \f[C]listener_persistent\f[R] set to \f[C]true\f[R].
Same for per\-command mode.
.IP \[bu] 2
If the server to which administrator connects using \f[C]cybercache\f[R] console application is consigured to use per\-command connections (i.e.\ has \f[C]listener_persistent\f[R] set to \f[C]false\f[R]), then said administrator should execute \f[C]persistent false\f[R] command before issuing any commands to the server (it would be a good idea to add \f[C]persistent false\f[R] to the \f[C]cybercache.cfg\f[R] file \[en] \f[I]not\f[R] to be confused with this \f[C]cybercached.cfg\f[R] file).
.IP \[bu] 2
If the server used as Magento session and/or full page cache is configured to use per\-command connections, then either a) Magento extension session/FPC configurations should have \f[C]persistent\f[R] set to \f[C]false\f[R], or b) Magento extension configuration should leave \f[C]persistent\f[R] unset, while PHP extension should have both \f[C]c3.session_persistent\f[R] and \f[C]c3.fpc_persistent\f[R] INI options set to \f[C]false\f[R].
.PP
It is recommended that these options are left at their default values.
.SS Option format:
.IP \[bu] 2
\f[C]listener_persistent <boolean>\f[R]
.IP \[bu] 2
\f[C]session_replicator_persistent <boolean>\f[R]
.IP \[bu] 2
\f[C]fpc_replicator_persistent <boolean>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]listener_persistent true\f[R]
.IP \[bu] 2
\f[C]session_replicator_persistent true\f[R]
.IP \[bu] 2
\f[C]fpc_replicator_persistent true\f[R]
.SS Options \- Replication
.PP
Replicators are configured just as the listener (see above), and have the same format and limits imposed on the number of concurrent addresses they can simultaneously transmit data to.
.PP
It is possible to use different ports for replicators (i.e.\ port number that differs from that of the listener), but it is not advised: it would make \[lq]hot swapping\[rq] of the servers more difficult, while providing no real benefits: unless replication server is used as, say, some sort of session log and is not actually part of the cluster.
.PP
It is possible to configure only session replicator, or only FPC replicator, or both.
If both are enabled, they can be \[lq]talking\[rq] to different, or to the same remote server.
The only limitation is that there must be a single CyberCache server running on a box: it is not possible to, say, have \[lq]live\[rq] and \[lq]replication\[rq] servers running on the same physical server, with different listener and replication ports (which wouldn\[cq]t make any sense anyway).
.SS Option format:
.IP \[bu] 2
\f[C]session_replicator_addresses <address> [<address> [...]]\f[R]
.IP \[bu] 2
\f[C]session_replicator_port <number>\f[R]
.IP \[bu] 2
\f[C]fpc_replicator_addresses <address> [<address> [...]]\f[R]
.IP \[bu] 2
\f[C]fpc_replicator_port <number>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]session_replicator_addresses 0 (NO DEFAULT)\f[R]
.IP \[bu] 2
\f[C]session_replicator_port 8120\f[R]
.IP \[bu] 2
\f[C]fpc_replicator_addresses 0 (NO DEFAULT)\f[R]
.IP \[bu] 2
\f[C]fpc_replicator_port 8120\f[R]
.IP \[bu] 2
\f[C]Even though these options are commented out by default, respective services\f[R]
.IP \[bu] 2
\f[C]*will* be started upon server startup. They just won\[aq]t be configured to talk\f[R]
.IP \[bu] 2
\f[C]to any remote address. This (configuration) can be done at run time by issuing\f[R]
.IP \[bu] 2
\[ga]\f[C]SET\f[R], \f[C]LOCALCONFIG\f[R], or \f[C]REMOTECONFIG\f[R] \[en] just as with \f[C]listener_xxx\f[R] options.\[ga]
.SS Options \- Table Hash Methods
.PP
These options set hash method that are used to process passwords, and to calculate hash codes of various entities: session and FPC entries\[cq] IDs or tags.
Every method has two important properties that has to be taken into account: the so\-called distribution (how likely is it that two different strings will get the same code), and speed.
All of the hash methods available represent state\-of\-the\-art in this area, with differences between them being very minor, so it\[cq]s hard to go wrong picking one over the other; still, some differences do exist:
.IP \[bu] 2
\f[C]xxhash\f[R] : extremely fast algorithm with good distribution, by Yann Collet; does not require any special hardware support,
.IP \[bu] 2
\f[C]farmhash\f[R] : very fast algorithm with extremely good distribution, from Google; requires support of SSE 4.2 instructions by your server hardware (if you select this method while not having required hardware, your server will crash); this is a second\-gen algorithm, successor to \[lq]cityhash\[rq]; this method can be recommended for very large datasets \f[I]IFF\f[R] your server runs on compatible hardware,
.IP \[bu] 2
\f[C]spookyhash\f[R] : algorithm by Bob Jenkins; almost as fast as Google\[cq]s, and without \f[C]farmhash\f[R]\[cq]s restrictions (special hardware requirements),
.IP \[bu] 2
\f[C]murmurhash2\f[R] : algorithm by Austin Appleby, used by Redis cache server,
.IP \[bu] 2
\f[C]murmurhash3\f[R] : next generation of the \f[C]murmurhash2\f[R] algorithm; has very good distribution, but is relatively (to the other algorithms, not in absolute terms!) slow.
.PP
Note that the need for best possible distribution is largerly mitigated in CyberCache by the fact that not only FPC and session data, but also FPC tags are stored separately; also, no IDs get any extra prefixes that have to be used in Redis\-based implementations of session storage of FPC.
Finally, whenever a particular algorithm on the above list is described as \[lq]fast\[rq], it simply means that it might be somewhat faster than others on that list; in absolute terms, they are all very fast.
.RS
.PP
\f[B]IMPORTANT\f[R]: if \f[C]password_hash_method\f[R] is set to a non\-default method and either \f[C]user_password\f[R] or \f[C]admin_password\f[R] is set, then
.IP "1)" 3
for PHP interface to be able to send commands that are authorized with passwords (that are set), PHP array entry \f[C]hasher\f[R] should be set in arrays passed to \f[C]c3_session()\f[R] and \f[C]c3_fpc()\f[R] to exactly the same method that is used in this config file,
.IP "2)" 3
similarly, for \f[C]cybercache\f[R] console to be able to execute authorized commands, \f[C]HASHER\f[R] command should be used to set the same method.
.RE
.RS
.PP
\f[B]IMPORTANT\f[R]: for the \f[C]password_hash_method\f[R] option to take effect, it must be specified in the cofiguration file before \f[C]user_password\f[R], \f[C]admin_password\f[R], and/or \f[C]bulk_password\f[R]; in other words, when server processes any of the specified passwords, it uses last encountered \f[C]password_hash_method\f[R] option (or, if none was specified, the default method).
.RE
.PP
These options are among the very few that cannot be changed at run time.
.SS Option format:
.IP \[bu] 2
\f[C]table_hash_method { xxhash | farmhash | spookyhash | murmurhash2 | murmurhash3 }\f[R]
.IP \[bu] 2
\f[C]password_hash_method { xxhash | farmhash | spookyhash | murmurhash2 | murmurhash3 }\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]table_hash_method xxhash\f[R]
.IP \[bu] 2
\f[C]password_hash_method murmurhash2\f[R]
.SS Options \- Passwords
.PP
Passwords in CyberCache are optional.
It is possible to set any (or all) of them to empty strings, and the server won\[cq]t complain.
If set, however, any of them should have at least one lower, one upper case letter, one digit, and have at least six characters (although failure to meet these requirements will result in a warning, not an error).
Please note that CyberCache server does not use passwords while establishing a connection; instead, every command is authenticated individually.
.PP
If \f[C]user_password\f[R] is set (i.e.\ isn\[cq]t an empty string), its hash code will be sent with each command that requires user\-level authentication (that\[cq]s all cache data\-transfer commands), will be checked by the server, and the command will be rejected if the password\[cq]s hash code does not match.
Similarly, if \f[C]admin_password\f[R] command is set, its hash code will be sent along with each command that requires admin\-level authentication (all configuration requests, \f[C]SHUTDOWN\f[R], and the likes; please see documentation).
.PP
The \f[C]bulk_password\f[R] command sets up authentication for replicators, binlogs, and databases: \f[C]bulk_password\f[R] on master must match \f[C]user_password\f[R] on slaves.
Also, bulk password hash code is stored instead of \f[C]user_password\f[R] along with data\-transfer commands saved to binlogs; hence \[lq]bulk\[rq].
.PP
The \f[C]info_password_type\f[R] option is a selector that determines which password, if any, is used to authenticate information commands such as \f[C]INFO\f[R], \f[C]STATS\f[R], \f[C]PING\f[R], and \f[C]CHECK\f[R].
If it is set to, say, \f[C]user\f[R] while \f[C]user_password\f[R] is an empty string, it would be equivalent to setting it to \f[C]none\f[R].
.PP
The recommended practice is to leave \f[C]user_password\f[R] empty, but set \f[C]admin_password\f[R]; the latter ensures that the server won\[cq]t be remotely re\-configured or shut down by a person not authorized to do so.
Do not hesitate to set \f[C]user_password\f[R] if you feel like it though: authentication in CyberCache is very lightweight (efficient).
The best (and, we should say, the only true) protection, as always, is running all servers in a LAN behind a good, properly configured firewall.
.SS Option format:
.IP \[bu] 2
\f[C]user_password <password>\f[R]
.IP \[bu] 2
\f[C]admin_password <password>\f[R]
.IP \[bu] 2
\f[C]bulk_password <password>\f[R]
.IP \[bu] 2
\f[C]info_password_type { none | user | admin }\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]user_password \[aq]\[aq]\f[R]
.IP \[bu] 2
\f[C]admin_password \[aq]\[aq]\f[R]
.IP \[bu] 2
\f[C]bulk_password \[aq]\[aq]\f[R]
.IP \[bu] 2
\f[C]info_password_type none\f[R]
.SS Options \- Logging
.PP
CyberCache logger is a full\-fledged logging service that runs cuncurrently with other server subsystems, is very lightweight, and supports not only basics like log levels, but also advanced features like log rotation.
.PP
Log levels are pretty self\-explanatory: \f[C]debug\f[R] is most verbose, while \f[C]explicit\f[R] essentially disables all internal logging, and will only write down messages that server receives through \f[C]LOG\f[R] command from, say, remote console; hence the name.
.PP
It is not recommended to use levels more terse than \f[C]warning\f[R].
The server counts all warnings and errors (irrespective of logging level in effect), and reports these numbers in responses to \f[C]INFO\f[R] and \f[C]CHECK\f[R] commands; server administrator should then be able to go to the log file to see what really happened.
Please note that reported numbers are cumulative, they are never reset (unless the server is restarted), so even if they are not zero but do not grow either, you might as well be fine.
.PP
The logger uses system log as a fallback.
During server startup and shutdown, as well as upon unrecoverable errors during normal operation, the server might log a message to syslog instead.
If the error occurs during startup, it is also duplicated to the standard error stream, so the person starting CyberCache will see it.
Otherwise, if an error occurred, log level is at \f[C]error\f[R] level or more verbose, but there are no traces of the the error in CyberCache own log, one has to check system log for messages about it.
On Windows, it is necessary to run \f[C]syslog\-ng\f[R] or equivalent service; on Linux, system log is always readily available.
.PP
In order to enable log rotation, one has to specify log rotation path, which is a regular file path that \f[I]must\f[R] have at least one date/time placeholder in it: either \[lq]%d\[rq] (which would be replaced with a integer value of current timestamp), or \[lq]%s\[rq] (which would be replaced with textual representation of the timestamp), but not both.
.SS Option format:
.IP \[bu] 2
\f[C]log_level { debug | verbose | normal | terse | warning | error | fatal | explicit }\f[R]
.IP \[bu] 2
\f[C]log_file <path>\f[R]
.IP \[bu] 2
\f[C]log_rotation_threshold <size>\f[R]
.IP \[bu] 2
\f[C]log_rotation_path <path>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]log_level normal\f[R]
.IP \[bu] 2
\f[C]log_file \[aq]/var/log/cybercache/cybercached.log\[aq]\f[R]
.IP \[bu] 2
\f[C]log_rotation_threshold 16M\f[R]
.IP \[bu] 2
\f[C]log_rotation_path \[aq]\[aq]\f[R]
.SS Options \- Concurrent Processing
.PP
At any moment, CyberCache runs 13 service threads, plus the number of worker threads set using \f[C]num_connection_threads\f[R]; the latter must be at least 1, and can be up to 6 in Community Edition, or up to 48 in Enterprise Edition.
.PP
Now, given that available number of CPU cores is almost guaranteed to be significantly less than the grand total of all server threads, does it really make sense to bump \f[C]num_connection_threads\f[R]?
Short answer is, Yes, it most certainly does.
First, vast majority of threads lay dormant most of the time, not consuming any system resorces (except for a wee bit of memory).
If not configured, binlog and replication threads do nothing at all.
If there is no logging, the logger thread does nothing, and so on.
.PP
The most \[lq]hard\-working\[rq] threads are those of the listener (which handles not only incoming, but also outgoing traffic), and optimization threads.
In a properly configured busy CyberCache server, activities of all threads (except \f[C]num_connection_threads\f[R] worker threads) result in utilization of 1.5..3 CPU cores, depending on binlog/replication settings.
.PP
Next question is, OK, suppose we have N cores in the system, and 2 cores worth of load because of service threads, does it make sense to set \f[C]num_connection_threads\f[R] to anything above N\-2?
The answer is, yes, it still does.
Even thought CyberCache server had been designed to avoid stalls during concurrent access to resources (by separating session and FPC stores, using multiple hash tables per store, using queues and messaging instead of locking a subsystem, and so on and so forth), some delays are inevitable.
A good rule of thump is this: if system has N cores, and estimated load due to service threads is M cores, set \f[C]num_connection_threads\f[R] to at least (N\-M)*2; if the difference in parenthes is zero or even negative, still set it to 2.
.RS
.PP
\f[B]IMPORTANT\f[R]: the \f[C]num_connection_threads\f[R] does \f[I]not\f[R] reflect the number of connections that CyberCache can handle concurrently; like Nginx and other high\-performance servers, CyberCache employs asynchronous I/O to handle connections, and can process hundreds and thouthans of connections simultaneourly, all within a single \[lq]listener\[rq] thread.
It is only when a request is received in full, it is passed for futher processing to a worker thread; all responses are handled similarly (except that the first attempt to write back response is done by the worker thread itself: another reason to have more of them).
.RE
.SS Option format:
.IP \[bu] 2
\f[C]num_connection_threads <number>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]num_connection_threads 2\f[R]
.SS Options \- Session Locking
.PP
Modern web sites may use more than one request to render a page, especially when such technologies as AJAX are used; in such cases, session read/write requests may come to CyberCache out of order.
Suppose two AJAX requests load, update, and store session data as follows: a) request 1 reads session record, b) request 2 reads same session record, c) request 1 writes \f[I]modified\f[R] session record, d) request 2 writes same \f[I]modified\f[R] session record.
If no special precautions are taken, all modification done by request number 1 would be lost.
.PP
CyberCache handles such situation using internal session locks: when it receives command to fetch session record, it locks that record until write command for that record issued by the \f[B]same\f[R] request (that previously read and thus locked the record) arrives.
Request IDs are automatically maintained by PHP extension; the \f[C]cybercache\f[R] console always uses zero request ID, thus bypassing all checks, and allowing to read/write session records in arbitrary order.
Invocation of a script using command line PHP interpreter is always treated by CyberCache extension as a single request (so cron jobs running PHP scripts manipulating session records using CyberCache PHP extension API have no restrictions, just like \f[C]cybercache\f[R] console scripts).
.PP
So far so good, but what if session write command never arrives after read command has locked session record?
This is where \f[C]session_lock_wait_time\f[R] option comes handy: it sets limit (measured in milliseconds) on the time that session read commands will be waiting for the record to be unlocked.
After that, one of the waiting read commands will break the lock, and lock the record by itself.
Default timeout is 8000 (milliseconds, or 8 seconds), and it can be set to anything from 0 (more on this below) to 60000 (that is, one minute).
.PP
When setting value of this option, the following should be taken into account: a) waiting thread does not \[lq]sleep for\[rq] session_lock_wait_time milliseconds, it \[lq]sleeps for UP TO\[rq] session_lock_wait_time milliseconds, and will wake up as soon as the record is unlocked \[en] so with properly working site it makes sense to set its value to tens of seconds to prevent timeouts even in case of severe site slowdowns; b) when thread wakes up due to a timeout (with bug in site implementation being a likely cause), it may find out that another thread/request already locked the record, in which case it will wait again for up to \f[I]another\f[R] session_lock_wait_time milliseconds \[en] so with a buggy site worst case scenario may be bad indeed.
If in doubt, just leave default value intact, it\[cq]s good enough for the majority of cases.
.PP
Finally, it is possible to set \f[C]session_lock_wait_time\f[R] option to 0, effectively disabling session locking.
This will work for sites that do not use AJAX, or similar technologies that utilize more than one request to render a page.
While it (disabling session locking) might provide some performance benefits, they will be absolutely negligible because locking is very efficient; do it if and \f[I]only\f[R] if you have to squeeze every last cycle out of a simple site under extremely heavy load.
.SS Option format:
.IP \[bu] 2
\f[C]session_lock_wait_time <milliseconds>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]session_lock_wait_time 8000\f[R]
.SS Options \- Cache Record Eviction Strategies
.PP
The following options set eviction modes for session and FPC caches.
Contrary to LRU eviction algorithms used by Redis, which are based on statistical approximation (see http://redis.io/topics/lru\-cache), CyberCache employs true LRU eviction, with data most recently \f[I]accessed\f[R] (i.e.\ \f[I]explicitly\f[R] tested, read, or written using server protocol) are \f[I]guaranteed\f[R] to be evicted later than \[lq]stale\[rq] data, and it does so using algorithms with O(1) complexity.
\f[I]All\f[R] modes described below use LRU eviction algorithm when it is necessary to free up some memory; the differences between them are that:
.IP \[bu] 2
\f[C]strict\-expiration\-lru\f[R] mode works like \f[C]expiration\-lru\f[R] (see below) but will not delete a record that has \f[I]not\f[R] expired unless total memory used by domain exceeds \f[C]max_session_memory\f[R] (for session domain) or \f[C]max_fpc_memory\f[R] (for FPC domain), or if total used memory exceeds global limit (\f[C]max_memory\f[R]); if those memory limits are set to \f[C]0\f[R], then in \f[C]strict\-expiration\-lru\f[R] mode the server will never delete a record that is not expired in respective domain unless it actually runs out of memory,
.IP \[bu] 2
\f[C]expiration\-lru\f[R] mode (the default) \f[I]does\f[R] take into account expiration timestamps and may purge expired records even when the server still has enough free memory; however, even in this mode the server 1) will remove a record with bigger TTL instead of a record that has smaller TTL but that was accessed more recently if it runs out of memory, 2) will \[lq]revive\[rq] expired records that are being tested or read (if they are have not been deleted yet),
.IP \[bu] 2
\f[C]lru\f[R] eviction is \[lq]pure\[rq] LRU and never removes expired records just because they have expired, although it still honors explicit garbage collection requests from the Magento application or server console (\f[C]GC\f[R] and \f[C]CLEAN OLD\f[R] commands, which delete expired records),
.IP \[bu] 2
\f[C]strict\-lru\f[R] mode works just like \f[C]lru\f[R], except that it ignores even explicit garbage collection requests.
.PP
Like other options, eviction mode for both session and FPC caches can be changed at run time; for this to work, even in \f[C]strict\-lru\f[R] mode the server always sets (and modifies as needed) expiration timestamps; it just never checks them.
.SS Option format:
.IP \[bu] 2
\f[C]session_eviction_mode { strict\-expiration\-lru | expiration\-lru | lru | strict\-lru }\f[R]
.IP \[bu] 2
\f[C]fpc_eviction_mode { strict\-expiration\-lru | expiration\-lru | lru | strict\-lru }\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]session_eviction_mode expiration\-lru\f[R]
.IP \[bu] 2
\f[C]fpc_eviction_mode lru\f[R]
.SS Options \- Session Records Life Times
.PP
These options implement fine\-grained control over session life time.
When a user loads site\[cq]s page for the very first time, we do not know whether he/she will visit another page or two, or will leave almost immediately.
So the server tracks number of session writes, and increases TTL for each successive write, because it becomes more and more probable that the user will return.
.RS
.PP
\f[B]IMPORTANT\f[R]: these options are \f[I]NOT\f[R] used if 1) user agent is a regular `user' (i.e.\ not an unknown user, a bot, or a cache warmer), AND 2) a specific lifetime (zero for \[lq]infinite\[rq], or a positive number) is sent to the server as part of the \f[C]WRITE\f[R] command.
.RE
.PP
Upon very first write of user\[cq]s session data, server sets session TTL to \f[C]session_first_write_lifetimes\f[R].
During next \f[C]session_first_write_nums\f[R] writes, the server linearly increases TTL until on \f[C]session_first_write_nums\f[R]\-th write it becomes equal to \f[C]session_default_lifetimes\f[R]; all subsequent writes will set TTL of that record to \f[C]session_default_lifetimes\f[R].
.PP
The \f[C]session_read_extra_lifetimes\f[R] option allows to revive expired but not yet deleted session records upon reads; if an expired but still existing session record is being read, the server will set its TTL to \f[C]session_read_extra_lifetimes\f[R].
Additionally, if \f[C]session_eviction_mode\f[R] is \f[I]not\f[R] \f[C]expiration\-lru\f[R], then upon each read of a session record (expired or not) the server will check its TTL and, if it\[cq]s less than \f[C]session_read_extra_lifetimes\f[R], the server will set it to \f[C]session_read_extra_lifetimes\f[R].
.PP
Each option takes up to four values, which have to be specified on the same line, as a sequence of numbers separated with whitespace.
Each number sets option value for a particular type of user agent (the type of user agent is deduced in PHP extension, there is no configuration option for it here):
.IP \[bu] 2
1st : for an unknown user (no user agent info in the request header),
.IP \[bu] 2
2nd : for a known bot, such as Google crawler,
.IP \[bu] 2
3rd : for the CyberHULL cache warmer,
.IP \[bu] 2
4th : for a potentially valid user of the site.
.PP
Lifetime of any element should not be set to less than 30 seconds, and it cannot be bigger than 365 days (you decide for how long you want to keep customers\[cq] shopping carts); \f[C]session_read_extra_lifetimes\f[R] can however be set to zeros to mimic a non\-LRU cache.
Note that using these settings you can also fully mimic Redis\-based session cache, which adds one second of extra lifetime per each session write (far from ideal in our opinion, but if you want to, then why not).
.SS Option format:
.IP \[bu] 2
\f[C]session_first_write_lifetime <duration> [ <duration> [ <duration> [ <duration> ]]]\f[R]
.IP \[bu] 2
\f[C]session_first_write_num <number> [ <number> [ <number> [ <number> ]]]\f[R]
.IP \[bu] 2
\f[C]session_default_lifetime <duration> [ <duration> [ <duration> [ <duration> ]]]\f[R]
.IP \[bu] 2
\f[C]session_read_extra_lifetime <duration> [ <duration> [ <duration> [ <duration> ]]]\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]session_first_write_lifetime 30s 1m 2m 10m\f[R]
.IP \[bu] 2
\f[C]session_first_write_num 100 50 20 10\f[R]
.IP \[bu] 2
\f[C]session_default_lifetime 1h 2h 1d 2w\f[R]
.IP \[bu] 2
\f[C]session_read_extra_lifetime 30s 1m 2m 2w\f[R]
.SS Options \- FPC Records Life Times
.PP
Options in this section control FPC entries\[cq] life times.
Overall, these options are much simpler than their counterparts for session cache, because Magento application explicitly specifies lifetime for the entry upon each write.
If the lifetime specified by Magento is not \f[C]\-1\f[R], than the server checks it against \f[C]fpc_max_lifetimes\f[R] and uses if it\[cq]s less than or equal to that (if specified value exceeds \f[C]fpc_max_lifetimes\f[R], it will be clipped).
Otherwise, if lifetime specified by Magento is \f[C]\-1\f[R], the server uses \f[C]fpc_default_lifetimes\f[R].
If \f[C]0\f[R] lifetime is passed to the server (as part of the \f[C]SAVE\f[R] command), it is treated by the server as \[lq]inifinite lifetime\[rq], and server disregards the below options.
.PP
The \f[C]fpc_read_extra_lifetimes\f[R] option allows to revive expired but not yet deleted FPC records upon reads; if an expired but still existing FPC record is being read, the server will set its TTL to \f[C]fpc_read_extra_lifetimes\f[R].
Additionally, if \f[C]fpc_eviction_mode\f[R] is \f[I]not\f[R] \f[C]expiration\-lru\f[R], then upon each read of an FPC record (expired or not) the server will check its TTL and, if it\[cq]s less than \f[C]fpc_read_extra_lifetimes\f[R], the server will set it to \f[C]fpc_read_extra_lifetimes\f[R].
.PP
Each option takes up to four values, which have to be specified on the same line, as a sequence of numbers separated with whitespace.
Each number sets option value for a particular type of user agent (the type of user agent is deduced in PHP extension, there is no configuration option for it here):
.IP \[bu] 2
1st : for an unknown user (no user agent info at all in the request header),
.IP \[bu] 2
2nd : for a known bot, such as Google crawler,
.IP \[bu] 2
3rd : for the CyberHULL cache warmer,
.IP \[bu] 2
4th : for a potentially valid user of the site.
.PP
Lifetime of any element cannot be set to less than 1 minute, and it cannot be bigger than 365 days; \f[C]fpc_read_extra_lifetime\f[R] can however be set to zeros to mimic a non\-LRU cache.
.SS Option format:
.IP \[bu] 2
\f[C]fpc_default_lifetimes <duration> [ <duration> [ <duration> [ <duration> ]]]\f[R]
.IP \[bu] 2
\f[C]fpc_read_extra_lifetimes <duration> [ <duration> [ <duration> [ <duration> ]]]\f[R]
.IP \[bu] 2
\f[C]fpc_max_lifetimes <duration> [ <duration> [ <duration> [ <duration> ]]]\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]fpc_default_lifetimes 1d 2d 20d 60d\f[R]
.IP \[bu] 2
\f[C]fpc_read_extra_lifetimes 1d 2d 20d 60d\f[R]
.IP \[bu] 2
\f[C]fpc_max_lifetimes 10d 30d 60d 60d\f[R]
.SS Options \- Optimization Intervals
.PP
These options define how often optimizers will go through all objects in session and FPC stores, and will try to optimize the stores, which includes purging old objects if \f[C]session_eviction_mode\f[R]/\f[C]fpc_eviction_mode\f[R] are in \f[C]strict\-expiration\-lru\f[R] or \f[C]expiration\-lru\f[R] modes, and re\-compressing the objects.
Re\-compression is very non\-intrusive, in that optimizers only very briefly lock an object before they begin its re\-compression, and after they have completed re\-compression (obviously, if the object data had been changed during re\-compression, re\-compression result would be discarded).
.PP
Optimizers take into account current server/CPU load, and adjust their activities accordingly.
Also, they treat records created by bots or unidentified user agents (or even own cache warmer) differently to records created by regular users, and will purge the former before the latter.
.SS Option format:
.IP \[bu] 2
\f[C]session_optimization_interval <duration>\f[R]
.IP \[bu] 2
\f[C]fpc_optimization_interval <duration>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]session_optimization_interval 20s\f[R]
.IP \[bu] 2
\f[C]fpc_optimization_interval 20s\f[R]
.SS Options \- Optimizers\[cq] Compression Methods
.PP
Set compression methods to be used by session and FPC optimizers, \f[I]and\f[R] the order in which those compressors will be tried.
When server receives data from the client, it is already in compressed form, but the compressor that PHP entension (or console) uses is relatively weak (has sub\-optimal compression ratio), although extremely fast.
After the data is stored in the cache, optimization threads will sooner or later detect unoptimal compression, and will re\-compress session or FPC data using the methods specified in \f[C]session_optimization_compressors\f[R] and \f[C]fpc_optimization_compressors\f[R] options, in the order the compressors are listed.
Available compression methods are:
.IP \[bu] 2
\f[C]zstd\f[R] : compressor from the creator of \f[C]lz4\f[R] compressor and \f[C]xxhash\f[R] hasher; compresses noticeably better than \f[C]gzip\f[R], decompression speed it approximately 3x that of \f[C]gzip\f[R]; its memory requirements during compression and decompression are modest, but still noticeably worse that those of \f[C]gzip\f[R]; this is the default.
.IP \[bu] 2
\f[C]brotli\f[R] : fast compressor by Google, with primary target being web traffic; has built\-in dictionary for that.
Only available in Enterprise Edition.
.IP \[bu] 2
\f[C]lzham\f[R] : compressor based on LZMA (alrorithm used by 7Zip), by a Valve engineer, made to be fast enough to be used in games; has very high compression ratio, with approximately 3x decompression speed with only slightly worse compression ratio compared to those of LZMA; compared to \f[C]gzip\f[R], it has almost 2x decompression speed and more than 1.5x compression ratio, but is a true memory hog during work.
.IP \[bu] 2
\f[C]zlib\f[R] : compressor used in gzip, a tried and proven solution, but sub\-optimal in great many respects; about the only reason to ever use this compressor is if the server small, is operating at peak capacity almost all the time, and there are simply no resources to employ a more powerful algorithm; in such a case, \f[C]zlib\f[R] should be the \f[I]only\f[R] method specified for the options.
That said, there is always a possibility that some particular piece of data (one in a 1000) can be compressed with \f[C]zlib\f[R] better than with any other method.
.IP \[bu] 2
\f[C]lzf\f[R], \f[C]snappy\f[R], \f[C]lz4\f[R], \f[C]lzss3\f[R] : these are super/hyper\-fast compressors with sub\-par compression ratios; any of them should \f[I]only\f[R] be used for \f[I]optimization\f[R] in\&... unusual setups with plenty of RAM and bandwidth but very scarse CPU resources.
In such a case, we\[cq]d recommend using \f[C]snappy\f[R] (the fastest of the bunch, by Google) in PHP extension for initial compression, and \f[C]lzf\f[R](almost as fast as \f[C]snappy\f[R], but compresses noticeably better, though still worse than even \f[C]zlib\f[R]) for the optimizers on the server side.
All these four methods are great for compressing responses though, see \f[C]xxx_response_compressor\f[R] family of options, below.
.RS
.PP
\f[B]IMPORTANT\f[R]: the \f[C]lz4\f[R] compressor currently cannot be used to compress records bigger than 2 gigabytes.
.RE
.PP
Optimizers have internal limits for the numbers of recompression attempts they are allowed to make during one run, and those limits vary according to current server/CPU load.
If you, say, specify two compression methods for \f[C]fpc_optimization_compressors\f[R], then FPC optimizer will try both and keep compressed buffer that is smaller, BUT it will also count that as \f[I]two\f[R] attempts; therefore, less attempts will remain to recompress other FPC records; also, using many compressors increases the likelihood of object data change during compression, which always results in scrapping re\-compression results; although, given enough time, optimizers will get to all records, eventually.
.PP
Compressors that do \f[I]not\f[R] belong to the \[lq]super\-fast\[rq] group support so\-called compression levels, ranging from \[lq]fastest but lest strong\[rq] to \[lq]slowest but strongest\[rq]; some compressors (namely \f[C]zstd\f[R], \f[C]brotly\f[R], and \f[C]lzham\f[R], but not \f[C]zlib\f[R]) also support \[lq]extreme\[rq] compression level, which are currently unused.
During optimization runs, CyberCache server always employs \[lq]strongest\[rq] compression level of each compresor, whereas during the following operations the \[lq]fastest\[rq] level is used:
.IP \[bu] 2
\f[C]cybercached\f[R] server packing a response (such as a list of IDs collected as a result of `GETIDS', \f[C]GETTAGS\f[R] or similar FPC command, or a list of strings formed as a result of \f[C]INFO\f[R], \f[C]STATS\f[R], or similar information command),
.IP \[bu] 2
\f[C]cybercache\f[R] console application packing a data buffer to send to the server as part of a \f[C]WRITE\f[R], \f[C]SAVE\f[R], or other such command,
.IP \[bu] 2
\f[C]cybercache.so\f[R] PHP extension packing a data buffer that it received as an argument to a \f[C]c3_write()\f[R], \f[C]c3_save()\f[R], or other such function.
.PP
If, say, CyberCache server has received a data buffer compressed using method \f[C]X\f[R], and optimizer is told to used methods \f[C]X\f[R], \f[C]Y\f[R], and \f[C]Z\f[R], then method \f[C]X\f[R] will \f[I]not\f[R] be tried by the optimizer on that buffer.
Which may, potentially, lead to inefficiency: received buffer was compressed using \[lq]fast\[rq] mode of the method, while optimizer would have used \[lq]strond\[rq] mode; therefore, it is not advised to use same methods for PHP extension and server optimizer: the former should be configured to use one of the fast compressors (\f[C]lzf\f[R], \f[C]snappy\f[R], \f[C]lz4\f[R], or \f[C]lzss3\f[R]), while the latter \[en] one of the strong methods.
.SS Option format:
.IP \[bu] 2
\f[C]session_optimization_compressors <method> [ <method> [...]]\f[R]
.IP \[bu] 2
\f[C]fpc_optimization_compressors <method> [ <method> [...]]\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]session_optimization_compressors zlib zstd\f[R]
.IP \[bu] 2
\f[C]fpc_optimization_compressors zlib zstd\f[R]
.SS Options \- Compression Size Thresholds
.PP
When optimization threads of the CyberCache server consider an object for re\- compression, they compare its size with values of the below options, and only proceed with re\-compression if object\[cq]s buffer size if equal to or greater than the threshold set by these options.
.PP
The thresholds used by CyberCache optimizers are smaller than those used by other cache solutions because:
.IP "1)" 3
there is virtually no performance penatly for the overall cache performance: re\-compression is done concurrently, in a separate thread, and does \f[I]not\f[R] affect in any way the timing of \f[C]SAVE\f[R]/\f[C]WRITE\f[R] commands,
.IP "2)" 3
some compressors used by CyberCache (e.g.\ \f[C]brotli\f[R]) have built\-in dictionaries; usually, entire compression dictionary has to be stored along with compressed data, thus making gains on small data negligible, and on tiny buffers can even enlarge the data instead of shrinking it; with built\-in dictionaries, compressing even tiny buffers may often provide some gains.
.PP
The \f[C]response_compression_threshold\f[R] option is different in that it controls how various lists etc.
are handled when they are sent back as responses to commands like \f[C]GETIDS\f[R] or \f[C]GETTAGS\f[R].
It does \f[I]not\f[R] affect returned session or FPC records in any way.
.RS
.PP
NOTE: setting any of these options to \f[C]4294967295\f[R] (that is, \f[C]2\[ha]32\-1\f[R]) effectively disables respective [re]compression.
.RE
.SS Option format:
.IP \[bu] 2
\f[C]session_recompression_threshold <size>\f[R]
.IP \[bu] 2
\f[C]fpc_recompression_threshold <size>\f[R]
.IP \[bu] 2
\f[C]response_compression_threshold <size>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]session_recompression_threshold 256b\f[R]
.IP \[bu] 2
\f[C]fpc_recompression_threshold 256b\f[R]
.IP \[bu] 2
\f[C]response_compression_threshold 2k\f[R]
.SS Options \- Numbers of Tabbles per Store
.PP
In order to maximize concurrent processing performance, CyberCache separates data on many levels; the biggest subdivision is that there are separate session and FPC stores, and the latter is further subdivided into FPC record store, and FPC tag store.
.PP
Each store can have multiple hash tables to keep data records, and options in this section define how many tables will there be per each store.
In general, the more tables, the less likely various delays become, although each extra table adds a bit of memory overhead (which is negligible for big setups, but not quite so for [very] small ones) \[en] so there has to be some balance.
.PP
The Community Edition of CyberCache server allows for up to 4 tables per store, while Enterprise Edition allows for up to 256 tables.
The number of tables must be a power of 2.
.SS Option format:
.IP \[bu] 2
\f[C]session_tables_per_store <number>\f[R]
.IP \[bu] 2
\f[C]fpc_tables_per_store <number>\f[R]
.IP \[bu] 2
\f[C]tags_tables_per_store <number>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]session_tables_per_store 2\f[R]
.IP \[bu] 2
\f[C]fpc_tables_per_store 4\f[R]
.IP \[bu] 2
\f[C]tags_tables_per_store 1\f[R]
.SS Options \- Health Check Interval
.PP
The \f[C]health_check_interval\f[R] option defines how often server\[cq]s main/configuration thread will wake up to do health check.
The check includes
.IP "1)" 3
making sure that the server actually listens to any addresses/ports,
.IP "2)" 3
checking that drives on which a) log file, b) session binlog file, and c) FPC binlog file reside still have at least \f[C]free_disk_space_warning_threshold\f[R] free bytes each,
.IP "3)" 3
checking that no thread (except binlog loader!) has spent more than \f[C]thread_activity_time_warning_threshold\f[R] milliseconds in \[lq]active\[rq] state processing an event that it received from its queue,
.PP
and logging warning messages if any of these checks fail; cumulative number of warnings (along with number or errors and server load) is sent back by both \f[C]CHECK\f[R] and \f[C]INFO\f[R] commands; one important difference between the two is that the latter also runs a health check by itself, while the former only reports results of previous scheduled health checks.
.SS Option format:
.IP \[bu] 2
\f[C]health_check_interval <duration>\f[R]
.IP \[bu] 2
\f[C]free_disk_space_warning_threshold <size>\f[R]
.IP \[bu] 2
\f[C]thread_activity_time_warning_threshold <milliseconds>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]health_check_interval 10m\f[R]
.IP \[bu] 2
\f[C]free_disk_space_warning_threshold 64M\f[R]
.IP \[bu] 2
\f[C]thread_activity_time_warning_threshold 5000\f[R]
.SS Options \- Response Compressors
.PP
These options control which compressors will be used to compress responses that are sent back by the server.
.PP
Compressor types are the same as used for \f[C]session_optimization_compressors\f[R] and \f[C]fpc_optimization_compressors\f[R] options, except that here only one compressor per option should be specified.
Please see those options\[cq] descriptions for information on compressor types.
.RS
.PP
\f[B]IMPORTANT\f[R]: compressors specified by \f[C]xxx_response_compressor\f[R] family of options are \f[I]never\f[R] used to re\-compress stored session/FPC records that are requested from the server.
They are only used to compress dynamic data created while processing the request, such as lists of IDs, \f[C]INFO\f[R] command output, and the likes.
.RE
.SS Option format:
.IP \[bu] 2
\f[C]global_response_compressor <compressor>\f[R]
.IP \[bu] 2
\f[C]session_response_compressor <compressor>\f[R]
.IP \[bu] 2
\f[C]fpc_response_compressor <compressor>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]global_response_compressor snappy\f[R]
.IP \[bu] 2
\f[C]session_response_compressor snappy\f[R]
.IP \[bu] 2
\f[C]fpc_response_compressor snappy\f[R]
.SS Options \- Integrity Checks
.PP
These options control whether integrity check bytes are sent at the end of commands and responses, or stored in binlog \[en] \f[I]not\f[R] whether integrity check is performed; presence of the integrity check is controlled by special bit in both command in response headers, and if it was sent (or stored), it will be checked by receiver (or loader) irrespective of these options\[cq] settings.
And, if the check fails, the command or response will be discarded, and error will be logged.
.PP
The \f[C]command_integrity_check\f[R] option controls sending integrity check bytes to replications servers; other options are self\-explanatory.
.SS Option format:
.IP \[bu] 2
\f[C]command_integrity_check <boolean>\f[R]
.IP \[bu] 2
\f[C]response_integrity_check <boolean>\f[R]
.IP \[bu] 2
\f[C]binlog_integrity_check <boolean>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]command_integrity_check true\f[R]
.IP \[bu] 2
\f[C]response_integrity_check false\f[R]
.IP \[bu] 2
\f[C]binlog_integrity_check true\f[R]
.SS Options \- Binlogs
.PP
Binlogs store session or FPC commands that alter data of the records stored in cache; commands that only request information (or change settings etc.) are never stored.
A binlog can be played back (essentially restoring contents of a store) using \f[C]RESTORE\f[R] console command, and that can be done without stopping the server, which can concurrently continue servicing other requests.
.PP
Binlogs are controlled pretty much like the regular log, in that it is possible to start the server with no binlog, and then issue \f[C]SET\f[R] command setting binlog path for a store, which will start binlog.
Similarly, in order to enable binlog rotation, it is necessary to specify binlog rotation path, which is a regular file path that \f[I]must\f[R] have at least one date/time placeholder in it: either \[lq]%d\[rq] (which would be replaced with current timestamp\[cq]s integer value), or \[lq]%s\[rq] (which would be replaced with textual representation of the timestamp), but not both.
Binlog will be rotated (i.e.
current file will be closed and renamed, and new file will be created) when binlog file size reaches threshold set by respective option.
Additionally, it is possible to force binlog rotation using \f[C]ROTATE\f[R] console command.
.PP
The \f[C]session_binlog_sync\f[R] and \f[C]fpc_binlog_sync\f[R] options contol how reliable is writting to the file; available synchronization modes are:
.IP \[bu] 2
\f[C]none\f[R] : output is buffered, power outage will likely currupt the binlog; this is the fastest, but least reliable mode,
.IP \[bu] 2
\f[C]data\-only\f[R] : data bytes are immediately written to underlying storage hardware; file size is updated, but some metadata (e.g.\ last modification timestamp) will be updated at some later time,
.IP \[bu] 2
\f[C]full\f[R] : not only data bytes, but file metadata are updeted immediately; this is the most reliable, but also the slowest mode.
.RS
.PP
\f[B]NOTE\f[R]: CyberCache Cluster writes binlogs in concurrent threads, worker threads that process requests do \f[I]not\f[R] wait for binlog to store update data, so even \[lq]slow\[rq] synchronization modes that would \[lq]kill\[rq] a single\-threaded cache might as well work just fine in CyberCache.
.RE
.RS
.PP
\f[B]IMPORTANT\f[R]: binlog file must reside in a directory that is writable by \f[C]cybercached\f[R]; even though the server does not set any default binlog file name, installation procedure does create directory where binlog files might/should reside: \f[C]/var/lib/cybercache\f[R], owned by user/group \f[C]cybercache\f[R]; it is highly recommeded that options described in this section point to files located in that directory.
If both session and FPC binlog names are specified, they \f[B]MUST\f[R] be different (or rather point to different files).
.RE
.PP
Enabling session binlog might make sense in many scenarious, while enabling FPC binlog \[en] only in environments with very high availability requirements.
.SS Option format:
.IP \[bu] 2
\f[C]session_binlog_file <path>\f[R]
.IP \[bu] 2
\f[C]fpc_binlog_file <path>\f[R]
.IP \[bu] 2
\f[C]session_binlog_rotation_path <path>\f[R]
.IP \[bu] 2
\f[C]fpc_binlog_rotation_path <path>\f[R]
.IP \[bu] 2
\f[C]session_binlog_rotation_threshold <size>\f[R]
.IP \[bu] 2
\f[C]fpc_binlog_rotation_threshold <size>\f[R]
.IP \[bu] 2
\f[C]session_binlog_sync { none | data\-only | full }\f[R]
.IP \[bu] 2
\f[C]fpc_binlog_sync { none | data\-only | full }\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]session_binlog_file \[aq]\[aq]\f[R]
.IP \[bu] 2
\f[C]fpc_binlog_file \[aq]\[aq]\f[R]
.IP \[bu] 2
\f[C]session_binlog_rotation_path \[aq]\[aq]\f[R]
.IP \[bu] 2
\f[C]fpc_binlog_rotation_path \[aq]\[aq]\f[R]
.IP \[bu] 2
\f[C]session_binlog_rotation_threshold 256M\f[R]
.IP \[bu] 2
\f[C]fpc_binlog_rotation_threshold 256M\f[R]
.IP \[bu] 2
\f[C]session_binlog_sync none\f[R]
.IP \[bu] 2
\f[C]fpc_binlog_sync none\f[R]
.SS Options \- Saving and Loading Databases
.PP
CyberCache can be configured to store all cache records on shutdown, and then re\-load them on startup.
Respective server options are completely independent from those used to manage binlogs, although some look and act similarly.
The options are set on a per\-store basis (i.e.\ separately for session and FPC record stores).
.PP
The \f[C]xxx_db_sync\f[R] options work just like \f[C]xxx_binlog_sync\f[R] counterparts, and control reliability of saving operations (what will happen if power goes down during saving of records), see the above description of similar binlog options; as always, there is tradeoff between speed and reliability.
.PP
The \f[C]xxx_db_include\f[R] options control which records will be saved at exit by setting \[lq]lowest\[rq] user agent type whose records has to be preserved.
They do \f[I]not\f[R] affect loading from databases on startup though: whatever was stored, will be loaded.
CyberCache keeps track of user agents that were creating records, so it is possible to differentiate them and only save \[lq]useful\[rq] ones.
If, say, \f[C]session_db_include\f[R] is set to \f[C]warmer\f[R], then session records created by cache warmer and regular users will be persisted, while records created by unknown users and bots will not.
.PP
Finally, \f[C]xxx_db_file\f[R] options set file names of the database files.
If those names contain slashes (`/'), they will be treated as full paths and used \[lq]as\-is\[rq]; otherwise, path prefix (currently, \f[C]/var/lib/cybercache\f[R]) will be added, for files to reside in CyberCache \[lq]database\[rq] directory.
.PP
The format of files created by \f[C]xxx_db_file\f[R] options is the same as that of binlogs, so it is possible to [re\-]load them any time using \f[C]RESTORE\f[R] console command, or \f[C]c3_restore()\f[R] method of PHP extension.
IFF session and FPC databases are written to separate files (see below for the discussion of the alternative), then employing \f[C]xxx_db_xxx\f[R] options is almost equivalent to excuting two \f[C]STORE\f[R] commands (or two \f[C]c3_store()\f[R] calls) right before server shutdown, and two \f[C]RESTORE\f[R] commands (or \f[C]c3_restore()\f[R] calls) right after startup.
Note that it\[cq]s \f[I]almost\f[R] equivalent though: the use of \f[C]xxx_db_xxx\f[R] options is still preferable as it\[cq]s more reliable: server data will survive any unexpected server restarts.
.RS
.PP
\f[B]NOTE\f[R]: it is possible (but \f[I]not\f[R] recommended) to specify the same name for both session and FPC database files; in this case, upon startup the server will load all the records only once, and on shutdown will save session and FPC records to the same file.
However, when server determines if files are \[lq]the same\[rq], it simply compares strings passed as arguments to \f[C]session_db_file\f[R] and \f[C]fpc_db_file\f[R], it does \f[B]not\f[R] check if different paths refer to the same file.
So if you, for instance, specify \f[C]my_db.blf\f[R] as session database and \f[C]/var/lib/cybercache/my_db.blf\f[R] (which refers to the same file in current CyberCache version) as FPC database, then on startup all records will be loaded twice (will cause no harm, but will result in a slowdown), and on shutdown you will lose all session records.
.RE
.SS Option format:
.IP \[bu] 2
\f[C]session_db_include { unknown | bot | warmer | user }\f[R]
.IP \[bu] 2
\f[C]session_db_sync { none | data\-only | full }\f[R]
.IP \[bu] 2
\f[C]session_db_file <name\-or\-path>\f[R]
.IP \[bu] 2
\f[C]fpc_db_include { unknown | bot | warmer | user }\f[R]
.IP \[bu] 2
\f[C]fpc_db_sync { none | data\-only | full }\f[R]
.IP \[bu] 2
\f[C]fpc_db_file <name\-or\-path>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]session_db_include user\f[R]
.IP \[bu] 2
\f[C]session_db_sync data\-only\f[R]
.IP \[bu] 2
\f[C]session_db_file \[aq]\[aq]\f[R]
.IP \[bu] 2
\f[C]fpc_db_include bot\f[R]
.IP \[bu] 2
\f[C]fpc_db_sync none\f[R]
.IP \[bu] 2
\f[C]fpc_db_file \[aq]\[aq]\f[R]
.SS Options \- Auto\-saving Databases
.PP
In addition to saving/loading session and/or FPC databases upon server shutdown and startup, it is also possible to configure CyberCache so that it would periodically dump its databases to the files during normal operation, at set intervals; that\[cq]s what \f[C]session_auto_save_interval\f[R] and \f[C]fpc_auto_save_interval\f[R] options are for.
If a server hosting CyberCache shuts down abnormally (say, because of a power outage) and is then restarted, CyberCache will automatically load last saved session and FPC cache records \[en] because auto\-saving utilizes all the parameters set using \f[C]session_db_xxx\f[R] and \f[C]fpc_db_xxx\f[R] options, which include names of the database files.
.PP
Setting \f[C]session_auto_save_interval\f[R] and/or \f[C]fpc_auto_save_interval\f[R] options to \f[C]0\f[R] disables auto\-saving for session and/or FPC store, respectively.
.RS
.PP
\f[B]NOTE\f[R]: It is also possible to make CyberCache store its databases not at set intervals, but at specified time(s).
Even though saving to a file does not normally slow down CyberCache (as it\[cq]s done in a separate, specialized thread), one may want to, say, only do that immediately before and after work hours, and one more time at midnight.
To do that, all that\[cq]s needed is to use \f[C]cybercache\f[R] console application and its \f[C]\-c\f[R]/\f[C]\-\-command\f[R] option, which makes the console execute specified command and quit.
The following command lines store session and FPC stores just as auto\-saving would do (with default settings; please see console \f[C]store\f[R] command description for more info):
.IP \[bu] 2
\f[C]cybercache \-c \[aq]store session session\-store\-db.blf user data\-only\[aq]\f[R]
.IP \[bu] 2
\f[C]cybercache \-c \[aq]store fpc fpc\-store\-db.blf bot none\[aq]\f[R]
.PP
All that is needed is to put the above commands into server \f[C]crontab\f[R], along with the information specifying when to run them.
If auto\-saving at other times is not needed, the \f[C]session_auto_save_interval\f[R] and \f[C]fpc_auto_save_interval\f[R] options should be set to zero.
.RE
.SS Option format:
.IP \[bu] 2
\f[C]session_auto_save_interval <duration>\f[R]
.IP \[bu] 2
\f[C]fpc_auto_save_interval <duration>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]session_auto_save_interval 0\f[R]
.IP \[bu] 2
\f[C]fpc_auto_save_interval 0\f[R]
.SS Options \- Include Files
.PP
Loads and parses another configuration file, as if contents of that file was included at the point where \f[C]include\f[R] statement was encountered.
.PP
If option argument (path of the file to include) starts with \f[C].\f[R] or \f[C]/\f[R], then it is used \[lq]as is\[rq]; othewise, the server will search for the file starting at the folder where file contaning \f[C]include\f[R] statement is located.
For instance, if current file is \[lq]/etc/cybercached.cfg\[rq], than \f[C]include cluster/ips.inc\f[R] will try to load and parse \[lq]/etc/cluster/ips.inc\[rq].
.PP
There can be any number of \f[C]include\f[R] statements in a configuration file (as well as \[lq]\-i\[rq]/\[lq]\[en]include\[rq] command line arguments), but the depth to which included files can be nested (i.e.\ `include' statements in included files) is restricted: Community Edition allows for up to two levels (base configuration file + one nested), while Enterprise Edition supports up to 8.
.SS Option format:
.IP \[bu] 2
\f[C]include <path>\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]NONE\f[R]
.SS Options \- Daemon Version
.PP
The `version' option actually cannot be set in the configuration file, but it is nonetheless mentioned here for the sake of completeness, because its value can be retrieved using \f[C]GET\f[R] command, as if it was a configurable option.
.SS Option format:
.IP \[bu] 2
\f[C]version\f[R]
.SS Default values:
.IP \[bu] 2
\f[C]<current\-cybercached\-version>\f[R]
.SS Performance Tuning
.PP
CyberCache server configuration file contains dozens of options with names starting with \f[C]perf_\f[R], which are \f[B]not\f[R] supposed to be changed by CyberCache users; please see comments in the configuration file for more info.
.SH AUTHORS
Vadim Sytnikov.
