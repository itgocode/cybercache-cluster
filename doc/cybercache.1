.\" Automatically generated by Pandoc 2.5
.\"
.ad l
.TH "cybercache" "1" "October 29, 2021" "Copyright (C) 2019 CyberHULL" "CyberCache CE 1.3.6 Command Interface"
.hy
.SH CyberCache Cluster: Command Interfaces
.PP
CyberCache Cluster suite provides three ways of communicating with the server (\f[C]cybercached\f[R] daemon):
.IP "1." 3
The \[lq]raw\[rq] TCP/IP interface (see separate network protocol documentation).
.IP "2." 3
Console interface (commands can be sent to it by the \f[C]cybercache\f[R] application that supports interactive and non\-interactive modes).
.IP "3." 3
PHP interface, through the \f[C]cybercache.so\f[R] PHP extension.
.PP
This manual documents the latter two; please refer to \f[C]cybercache(5)\f[R] man page (or \f[C]CyberCache_Network_Protocol.pdf\f[R]) for information on basic structure of CyberCache network packets, definitions of \[lq]chunks\[rq], and other low\-level stuff (even though command descriptions in this file do include \f[C]Request sequence\f[R] and \f[C]Server response\f[R] sub\-sections, it may be necessary to refer to protocol documentation for information on individual chunks).
.PP
By default, CyberCache server listens to port 8120; see List of TCP and UDP port numbers (https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers); a different value can be specified using \f[C]listener_port\f[R] configuration file option.
Any option in the server configuration file \f[B]only affects server (\f[CB]cybercached\f[B])\f[R] and its responses, but has no effect on the server console (\f[C]cybercache\f[R]), which may (and on many occasions will) reside on a different host.
.SS Getting More Help
.PP
Even though this manual covers \f[C]cybercache\f[R] (console application used to communicate with \f[C]CyberCache\f[R]) usage quite extensively, one can also get extra help by starting \f[C]cybercache\f[R] and executing its \f[C]help\f[R] command.
Additionally, \f[C]help <command>\f[R] will print out instructions for that particular command.
.PP
As to configuring \f[C]cybercached\f[R] daemon itself, its default configuration file \f[C]/etc/cybercache/cybercached.cfg\f[R] contains detailed descriptions of all \[lq]user\-servicable\[rq] options, including their possible values, effects, as well as recommended settings.
.SS Testing CyberCache Server
.PP
To test CyberCache installation, follow these steps:
.IP "1)" 3
Make sure that PHP 7.0 is (still) installed; if not:
.RS 4
.PP
sudo apt install php
.RE
.PP
and check that it\[cq]s PHP 7.0:
.IP
.nf
\f[C]
php \-v
\f[R]
.fi
.IP "2)" 3
Follow instructions in \[lq]/usr/lib/cybercache/tests/README.md\[rq]
.SS PHP Interface
.PP
CyberCache PHP resource is created with a call to one of the following methods (the \f[C]$resource\f[R] argument to PHP methods, in the below documentation, refers to a resource returned by one of these functions):
.IP \[bu] 2
\f[C]resource c3_session(array $options=null)\f[R]
.IP \[bu] 2
\f[C]resource c3_fpc(array $options=null)\f[R]
.PP
The methods take optional associative array and, if successful, return PHP resource.
In case of an error, these methods report it using standard PHP means (error message will be printed to the console if PHP is run as a command\-line interpreter, or will be written to Apache error log if PHP is run as Apache module), and then throw \f[C]Exception\f[R].
These methods differ from other CyberCache extension methods in their error handling because they are meant to be used in class constructors that do not have error return values, and would have to throw an exception on their own anyway.
.PP
The following options (option array keys) can be specified during resource creation; note that all values (even representing numbers, such as compression threshold) \f[B]must\f[R] be PHP strings:
.IP \[bu] 2
\f[C]address\f[R] : address to connect to (default is \f[C]127.0.0.1\f[R]),
.IP \[bu] 2
\f[C]port\f[R] : port to connect to (default is \f[C]8120\f[R]),
.IP \[bu] 2
\f[C]hasher\f[R] : what hash method to use for passwords (default is \f[C]murmurhash2\f[R]),
.IP \[bu] 2
\f[C]admin\f[R] : administrator password to pass to admin\-level commands (default it none),
.IP \[bu] 2
\f[C]user\f[R] : user password to pass to user\-level commands (default it none),
.IP \[bu] 2
\f[C]compressor\f[R] : what compression method to use (default is \f[C]snappy\f[R]),
.IP \[bu] 2
\f[C]threshold\f[R] : minimum size of the buffer eligible for compression (default is \f[C]4096\f[R]),
.IP \[bu] 2
\f[C]marker\f[R] : whether to send integrity checks after each command (default is \f[C]true\f[R]).
.PP
All options can also be set in the configuration file; for sessions, the options are \f[C]c3.session_<option>\f[R], and for FPC they look like \f[C]c3.fpc_<option>\f[R], where \f[C]<option>\f[R] is one of those that can be passed to \f[C]c3_session()\f[R] or \f[C]c3_fpc()\f[R]; these options can be set at any time using standard PHP \f[C]ini_set()\f[R] function.
.RS
.PP
\f[B]IMPORTANT\f[R]: for hashing algorithm setting to take effect:
.IP "1)" 3
the \f[C]c3.session_hasher\f[R] must precede both \f[C]c3.session_user\f[R] and/or \f[C]c3.session_admin\f[R] options in the PHP INI file; the same order must be kept when setting these options using \f[C]ini_set()\f[R] function,
.IP "2)" 3
the \f[C]c3.fpc_hasher\f[R] must precede both \f[C]c3.fpc_user\f[R] and \f[C]c3.fpc_admin\f[R] options in the PHP INI file; the same order must be kept when setting these options using \f[C]ini_set()\f[R] function,
.IP "3)" 3
the \f[C]hasher\f[R] key must precede both \f[C]user\f[R] and \f[C]admin\f[R] keys in the array passed to \f[C]c3_session()\f[R] and/or \f[C]c3_fpc()\f[R] extension functions,
.IP "4)" 3
the \f[C]password_hash_method\f[R] server configuration option must be specified in the server cofiguration file before \f[C]user_password\f[R], \f[C]admin_password\f[R], and/or \f[C]bulk_password\f[R] options.
.PP
In other words, whenever a password is processed by the server or PHP extension, last encountered password hashing method is used (or, if none was specified, the default method).
Password hashing method is an advanced setting; if in doubt \[en] just do not alter it, default value is good enough.
.RE
.PP
In addition, there are two global options:
.IP \[bu] 2
\f[C]c3.bot_regex\f[R] option that can be used to set regular expression pattern for web bot detection; contrary to all other options, this option can only be set in PHP ini file (or using `\-d' PHP command line argument), and cannot be changed at run time, and
.IP \[bu] 2
\f[C]c3.info_password_type\f[R] option that controls authentication level for so\-called information commands (\f[C]PING\f[R], \f[C]CHECK\f[R], \f[C]INFO\f[R], and \f[C]STATS\f[R]); its value \f[I]must\f[R] match that of the server \f[C]info_password_type\f[R] option (see server configuration file for allowed values).
.RS
.PP
\f[I]IMPORTANT\f[R]: not only keys, but also all values of the options passed to \f[C]c3_session()\f[R] and \f[C]c3_fpc()\f[R] functions \f[B]must\f[R] be strings; moreover, options that are booleans are processed just like INI option values, which meands that \f[C]on\f[R], \f[C]yes\f[R], \f[C]true\f[R] and all strings thar represent nonzero numbers are treated as boolean values of \f[C]true\f[R], and \f[I]all\f[R] other strings as boolean \f[C]false\f[R].
.RE
.PP
PHP functions that do actual communication accept resource handle as their first argument, and return a boolean, an integer number, a binary string, or an array; error return is a \f[C]false\f[R] or a \f[C]null\f[R].
If a method\[cq]s return value is conceptually boolean, the method is implemented as returning an \f[C]int\f[R] (\f[C]0\f[R] or \f[C]1\f[R]) to be able to use \f[C]false\f[R] as error return.
In case of an error, respective error message for last API call during current session can then be fetched with \f[C]c3_get_last_error()\f[R], which would return an empty string if called after a successful communication/transaction.
.RS
.PP
\f[I]IMPORTANT\f[R]: the \f[C]c3_get_last_error()\f[R] function only returns errors returned by the \f[I]server\f[R]; errors encountered elsewhere (e.g.\ during processing of some extension function\[cq]s arguments) will \f[I]not\f[R] be returned.
.RE
.PP
Resources created using \f[C]c3_session()\f[R] and \f[C]c3_fpc()\f[R] functions do not need to be released explicitry; they will be disposed automatically when the last variable referencing them goes out of scope.
.PP
Apart from functions necessary to support FPC operations per se, there is one extra PHP function, \f[C]get_capabilities()\f[R], which returns capabilities of FPC backend as associative array with the following keys and boolean values (the values shown below are what current version of CyberCache PHP extension returns upon the \f[C]get_capabilities()\f[R] call):
.IP \[bu] 2
`automatic_cleaning' => \f[C]false\f[R] (does Magento have to do periodic cleaning of the cache?)
.IP \[bu] 2
`tags' => \f[C]true\f[R] (does backend support FPC records\[cq] tags?),
.IP \[bu] 2
`expired_read' => \f[C]true\f[R] (is it possible to read an expired record?),
.IP \[bu] 2
`priority' => \f[C]false\f[R] (does backend support \f[I]explicitly\f[R] specified record \[lq]priorities\[rq]?),
.IP \[bu] 2
`infinite_lifetime' => \f[C]true\f[R] (is it possible to set \[lq]infinite\[rq] lifetime for a record?),
.IP \[bu] 2
`get_list' => \f[C]true\f[R] (is it possible to get complete list of record IDs [and tags]?).
.SS Console Interface
.PP
Console is case\-insensitive as far as commands and their arguments \f[I]that are keywords\f[R] are concerned (so, for instance, one can enter \f[C]INFO FPC\f[R], or \f[C]INFO fpc\f[R], or \f[C]info FPC\f[R], or \f[C]Info fPC\f[R]; they will all work).
Console accepts binary data as quoted strings (using single or double quotes).
Within any string, the following escape sequences are recognized and processed:
.IP \[bu] 2
\f[C]\[rs]\[rs]\f[R] : backslash,
.IP \[bu] 2
\f[C]\[rs]xx\f[R] : character with hexadecimal code \f[C]xx\f[R] (in upper or lower case),
.IP \[bu] 2
\f[C]\[rs]r\f[R] : carriage return,
.IP \[bu] 2
\f[C]\[rs]n\f[R] : line feed (new line),
.IP \[bu] 2
\f[C]\[rs]t\f[R] : tabulation (tab character),
.IP \[bu] 2
\f[C]\[rs]\[aq]\f[R] : apostrophe (single quote),
.IP \[bu] 2
\f[C]\[rs]\[aq]\f[R] : backtick (back quote / grave accent),
.IP \[bu] 2
\f[C]\[rs]\[dq]\f[R] : double quote.
.RS
.PP
\f[I]NOTE\f[R]: Other common escape sequences (such as \f[C]\[rs]a\f[R] for beep, \f[C]\[rs]b\f[R] for backspace, \f[C]\[rs]e\f[R] for Escape, or for \f[C]\[rs]f\f[R] form feed) are not supported as they would interfere with hexadecimal codes).
.RE
.PP
Whenever it is necessary to enter duration through console (say, as an argument to the \f[C]SET\f[R] command), it is possible to use \f[C]s\f[R] (seconds, the default), \f[C]m\f[R] (minutes), \f[C]h\f[R] (hours), \f[C]d\f[R] (days), or \f[C]w\f[R] (weeks) suffixes.
Likewise, to enter memory size, one can use suffixes \f[C]b\f[R] (bytes, the default/implied), \f[C]k\f[R] (kilobytes), \f[C]m\f[R] (megabytes), \f[C]g\f[R] (gigabytes), or \f[C]t\f[R] (terabytes).
When it is necessary to enter an array (again, for a command like \f[C]SET\f[R]), its individual elements should be separated by one or more spaces.
.PP
Just like in configuration file, in console boolean values can be specified using reserved words \f[C]true\f[R], \f[C]yes\f[R], \f[C]on\f[R], \f[C]false\f[R], \f[C]no\f[R], and \f[C]off\f[R], in either upper or lower (or even mixed) case.
.PP
If first non\-space character of an entered line is a hash mark (\f[C]#\f[R]), the rest of the line will be ignored.
.PP
If command is entered without arguments \f[I]and\f[R] its name contains asterisk character(s) (\f[C]*\f[R]), the command name is treated as a mask, and console would print out list of all commands that match that mask.
.PP
Console interface conventions almost completely match those of the server configuration file.
.SS Interface Commands
.PP
These are commands used to interact with console, and do not have counterparts in PHI API, or server protocol.
.SS \f[C]HELP\f[R]
.PP
Lists all supported commands, or describes a particular command.
The question mark (\f[C]?\f[R]) is an alias for \f[C]help\f[R], but can only be used without arguments (that is, \f[C]? <console\-command\f[R] is \f[I]not\f[R] supported).
.PP
Syntax:
.IP
.nf
\f[C]
HELP [ <console\-command> ]
\f[R]
.fi
.SS \f[C]VERSION\f[R]
.PP
Prints out console version.
To get server version, it is necessary to execute \f[C]GET version\f[R] command.
.PP
Syntax:
.IP
.nf
\f[C]
VERSION
\f[R]
.fi
.SS \f[C]VERBOSITY\f[R]
.PP
Allows to set verbosity of the messages output by console.
Setting verbosity level to, say, \f[C]terse\f[R], or any other less verbose level than \f[C]normal\f[R] (which is the default) may benefit execution of console scripts, as it will reduce \[lq]noise\[rq] in the output.
.RS
.PP
This console command has no effect on the server; to control verbosity of server output, use \f[C]SET log_level <level>\f[R] command instead; similarly, use \f[C]GET log_level\f[R] to retrieve current value.
.RE
.PP
Syntax:
.IP
.nf
\f[C]
VERBOSITY [ debug | verbose | normal | terse | warning | error | fatal | explicit ]
\f[R]
.fi
.SS \f[C]EXECUTE\f[R]
.PP
Loads file specified as argument and executes commands contained in it.
.RS
.PP
\f[B]IMPORTANT\f[R]: if argument file contains \f[C]ADMIN\f[R] or \f[C]USER\f[R] commands, those commands can have arguments \[en] password values (\f[I]not\f[R] recommended!).
If arguments to password\-setting commands are not specified, console will prompt the user to enter them.
.RE
.PP
Loaded files can also contain \f[C]EXECUTE\f[R] commands that load and process other files; recursion depth is limited by \f[C]2\f[R] in Community Edition, and 8 in Enterprise version of the CyberCache Cluster.
.PP
Syntax:
.IP
.nf
\f[C]
EXECUTE <command\-file\-path>
\f[R]
.fi
.SS \f[C]EXIT\f[R] / \f[C]QUIT\f[R] / \f[C]BYE\f[R]
.PP
Closes console session and exits to the operating system.
The server keeps running (to shut down the server, \f[C]SHUTDOWN\f[R] command should be used).
.RS
.PP
Note that \f[C]EXIT\f[R] command has two aliases: \f[C]QUIT\f[R] and \f[C]BYE\f[R], which do exactly the same.
.RE
.PP
Syntax:
.IP
.nf
\f[C]
EXIT | QUIT | BYE
\f[R]
.fi
.SS Auxiliary Commands
.PP
Commands in this section have immediate affect on \f[C]cybercache\f[R] console only, so almost all regular subsections are omitted for clarity.
Other console\-only commands (e.g.\ \f[C]HELP\f[R] or \f[C]EXIT\f[R]) are not in this section because they do not affect subsequently executed commands.
.PP
Some of these commands have counterparts in PHP API, in that there are \f[C]CyberCache\f[R] configuration methods that can (or sometimes must) be called on the instance of \f[C]CyberCache\f[R] class before executing commands that actually connect to the server; whenever that is the case, respective commands\[cq] descriptions have \f[C]PHP extension method:\f[R] subsections.
.RS
.PP
IMPORTANT: almost all settings controlled by these commands have sensible defaults; it is \f[I]not necessary\f[R] to execute them before the commands they affect.
Even \f[C]CONNECT\f[R] command can be omitted, in which case the console will send commands to \f[C]localhost\f[R] (\f[C]127.0.0.1\f[R]) using default port 8120.
.RE
.PP
When invoked without an argument, these commands return (print out) currently stored value(s) that will be used when another command, the one that they affect, will be executed \[en] except for `ADMIN' and `USER' commands, which would only tell if respective password is set or not.
.SS \f[C]CONNECT\f[R]
.PP
Sets network address and, optionally, port to connect to while executing server commands.
The address can be specified as either IP address, or a host name without protocol prefix.
In latter case, it will be resolved to IP address and printed out.
If port number is omitted, the default value of 8120 will be used.
Specified values will remain in effect till end of the session, or until another \f[C]CONNECT\f[R] command is executed.
.PP
Syntax:
.IP
.nf
\f[C]
CONNECT [ <network\-address> [ <port\-number> ]]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
c3.session_address
c3.fpc_address
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
address
\f[R]
.fi
.SS \f[C]PERSISTENT\f[R]
.PP
Specifies whether future connections to the server should be persistent, or if the console should hang up after issuing each command.
Default value (if `persistent ' is never executed) is `true'.
If the command is executed without an argument, current setting will be printed.
It is important that the same type of connections (per\-command or persistent) are used by all components of the CyberCache cluster.
.PP
Syntax:
.IP
.nf
\f[C]
PERSISTENT [ <boolean> ]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
c3.session_persistent
c3.fpc_persistent
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
persistent
\f[R]
.fi
.SS \f[C]USER\f[R]
.PP
Reads password that will then be passed on withing all commands that require user\-level authentication.
Does not accept any arguments; instead, it enters password\-input mode, and will accept input on a new line, \f[I]not\f[R] echoing characters being typed.
Entered value remains in effect until end of the session, or until another \f[C]USER\f[R] command is executed.
If this console command had never been executed but \f[C]ADMIN\f[R] command had, user\-level commmands will be issued with admin password instead.
If neither password had been set, user\-level commands will be issued without password.
.PP
Syntax:
.IP
.nf
\f[C]
USER
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
c3.session_user
c3.fpc_user
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
user
\f[R]
.fi
.SS \f[C]ADMIN\f[R]
.PP
Reads password that will then be passed on withing all commands that require admin\-level authentication (and, if \f[C]USER\f[R] password had not been entered, along with all commands requiring user\-level authentication).
Does not accept any arguments; instead, it enters password\-input mode, and will accept input on a new line, \f[I]not\f[R] echoing characters being typed.
Entered value remains in effect until end of the session, or until another \f[C]USER\f[R] command is executed.
If this console command had never been executed, admin\-level commands will be issued without password.
.PP
Syntax:
.IP
.nf
\f[C]
ADMIN
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
c3.session_admin
c3.fpc_admin
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
admin
\f[R]
.fi
.SS \f[C]USERAGENT\f[R]
.PP
Affects subsequent \f[C]READ\f[R], \f[C]WRITE\f[R], \f[C]LOAD\f[R], \f[C]TEST\f[R], and \f[C]SAVE\f[R] commands by passing them type of user agent that stores data (which can affect record lifetime).
Entered value remains in effect until end of the session, or until another \f[C]USERAGENT\f[R] command is executed; re\-connecting to the server does not change this setting.
The following user agents are recognized:
.IP \[bu] 2
\f[C]unknown\f[R] : (0x00) an unknown bot (empty \[lq]user agent\[rq] in the request, or one that \f[I]starts\f[R] with \f[C]curl\f[R]),
.IP \[bu] 2
\f[C]bot\f[R] : (0x01) a known bot; PHP extension detects it with the following regexp: `/^alexa|^blitz.io|bot|^browsermob|crawl|^facebookexternalhit|feed|google web preview|^ia_archiver|indexer|^java|jakarta|^libwww\-perl|^load impact|^magespeedtest|monitor|^Mozilla$|nagios |^.net|^pinterest|postrank|slurp|spider|uptime|\[ha]wget|yandex/i',
.IP \[bu] 2
\f[C]warmer\f[R] : (0x02) CyberHULL cache warmer (has \[lq]CyberCache.\[rq] in the request),
.IP \[bu] 2
\f[C]user\f[R] : (0x03) probably a valid user, not a bot (the default).
.RS
.PP
\f[I]NOTE\f[R]: order of constants is such that it arranges data marked with them in order from most likely to least likely to get kicked out during optimization / garbage collection processes.
.RE
.PP
Syntax:
.IP
.nf
\f[C]
USERAGENT [ <agent\-type> ]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.SS \f[C]TAGS\f[R] / \f[C]ADDTAGS\f[R] / \f[C]REMOVETAGS\f[R]
.PP
Affect subsequent \f[C]SAVE\f[R] commands by passing them list of tags to be associated with the record.
Entered list remains in effect until end of the session, or until another \f[C]TAGS\f[R], or \f[C]ADDTAGS\f[R], or \f[C]REMOVETAGS\f[R] command is executed; re\-connecting to the server does not change this setting.
.PP
The \f[C]TAGS\f[R] command completely replaces the list that is in effect at the time of command execution, while \f[C]ADDTAGS\f[R] and \f[C]REMOVETAGS\f[R] commands add or remove tags to the current list, respectively.
.RS
.PP
NOTE: only \f[C]TAGS\f[R] command can be specified without arguments (displaying current list of tags), while \f[C]ADDTAGS\f[R] and \f[C]REMOVETAGS\f[R] commands must have at least one argument.
.RE
.PP
Syntax:
.IP
.nf
\f[C]
TAGS [ <tag> [ <tag> [[ ... ]]]]
ADDTAGS <tag> [ <tag> [[ ... ]]]
REMOVETAGS <tag> [ <tag> [[ ... ]]]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.SS \f[C]LIFETIME\f[R]
.PP
Affects subsequent \f[C]WRITE\f[R] and \f[C]SAVE\f[R] commands by passing them record lifetime (number of seconds, or a special value; see below).
Entered value remains in effect until end of the session, or until another \f[C]LIFETIME\f[R] command is executed; re\-connecting to the server does not reset this setting.
.PP
Specifying lifetime of \f[C]0\f[R] means \[lq]infinite\[rq].
Specifying \f[C]\-1\f[R] (the default) means use whatever default value had been set in the configuration file using the \f[C]session_default_lifetimes\f[R] or \f[C]fpc_default_lifetimes\f[R] options for a specific user agent (that will be in effect at the time of \f[C]LOAD\f[R]/\f[C]SAVE\f[R] execution).
Using value bigger than one set by \f[C]fpc_max_lifetime\f[R] does not generate an error (because console neither uses configuration file, nor communicates with the server while executing the \f[C]LIFITIME\f[R] command), but subsequent \f[C]SAVE\f[R] command will clip expiration time to current time plus \f[C]fpc_max_lifetime\f[R].
.PP
Syntax:
.IP
.nf
\f[C]
LIFETIME [ <duration> ]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.SS \f[C]MARKER\f[R]
.PP
Affects all subsequent commands in that it controls whether integrity check marker will be added after each command.
Entered value remains in effect until end of the session, or until another \f[C]MARKER\f[R] command is executed; re\-connecting to the server does not reset this setting.
.PP
Syntax:
.IP
.nf
\f[C]
MARKER [ yes | no | on | off | true | false ]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
c3.session_marker
c3.fpc_marker
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
marker
\f[R]
.fi
.SS \f[C]THRESHOLD\f[R]
.PP
Sets minimal size for the data (being sent to the server) to be eligible for compression attempt.
This option does not affect the server in any way, the server compression is controlled by the options in its configuration file.
If size of the data (such as a session or FPC record) is less than the threshold, it will always be sent to the server uncompressed.
.PP
Setting this option to 4294967295 (that is, 2\[ha]32\-1) essentially disable compression of the outbound data.
.PP
Syntax:
.IP
.nf
\f[C]
THRESHOLD [ <positive\-number> ]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
c3.session_threshold
c3.fpc_threshold
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
threshold
\f[R]
.fi
.SS \f[C]COMPRESSOR\f[R]
.PP
Specifies which compressor will be used for commands that contain payloads, such as \f[C]WRITE\f[R] and \f[C]SAVE\f[R].
Entered value remains in effect until end of the session, or until another \f[C]COMPRESSOR\f[R] command is executed; re\-connecting to the server does not reset this setting.
Argument can be one of the following (see configuration file for info on speed and strengths of these algoritms):
.IP \[bu] 2
\f[C]lzf\f[R] : LZF by Marc Alexander Lehmann
.IP \[bu] 2
\f[C]snappy\f[R] : Snappy by Google (the default)
.IP \[bu] 2
\f[C]lz4\f[R] : LZ4 by Yann Collet (cannot compress buffers bigger than 2 gigabytes)
.IP \[bu] 2
\f[C]lzss3\f[R] : LZSS by Haruhiko Okumura
.IP \[bu] 2
\f[C]brotli\f[R] : Brotli by Jyrki Alakuijala and Zoltan Szabadka
.IP \[bu] 2
\f[C]zstd\f[R] : Zstd by Yann Collet (Facebook, Inc.)
.IP \[bu] 2
\f[C]zlib\f[R] : Zlib (gzip) by Jean\-loup Gailly and Mark Adler
.IP \[bu] 2
\f[C]lzham\f[R] : Lzham by Richard Geldreich, Jr.
.PP
Note that this command controls compression of payloads of issued \f[I]commands\f[R]; which compressor will be used to compress payloads of responses is controlled by respective options in server configuration files.
.PP
Syntax:
.IP
.nf
\f[C]
COMPRESSOR [ lzf | snappy | lz4 | lzss3 | brotli | zstd | zlib | lzham ]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
c3.session_compressor
c3.fpc_compressor
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
compressor
\f[R]
.fi
.SS \f[C]HASHER\f[R]
.PP
Specifies which hashing algorithm will be used to for passwords entered via \f[C]USER\f[R] and \f[C]ADMIN\f[R] commands.
Entered value remains in effect until end of the session, or until another \f[C]HASHER\f[R] command is executed; re\-connecting to the server does not reset this setting.
Argument can be one of the following (see configuration file for more detailed descriptions):
.IP \[bu] 2
\f[C]xxhash\f[R] : extremely fast algorithm with good distribution, by Yann Collet,
.IP \[bu] 2
\f[C]farmhash\f[R] : very fast algorithm with extremely good distributionby Google; requires support of SSE 4.2 instructions by CPU,
.IP \[bu] 2
\f[C]spookyhash\f[R] : algorithm by Bob Jenkins, almost as fast as Google\[cq]s; does not require any special hardware support,
.IP \[bu] 2
\f[C]murmurhash2\f[R] : the algorithm by Austin Appleby, used by Redis cache server,
.IP \[bu] 2
\f[C]murmurhash3\f[R] : next generation of the \f[C]murmurhash2\f[R] algorithm.
.PP
Default value is \f[C]murmurhash2\f[R].
.RS
.PP
\f[B]IMPORTANT\f[R]: if non\-default password hash method is set in the configuration file using \f[C]password_hash_method\f[R] option, AND either user or administrative password is set (using \f[C]user_password\f[R] or \f[C]admin_password\f[R] option, respectively), then \f[C]HASHER\f[R] command \f[B]must\f[R] be executed in the console before execution of any command that requires authentication.
And, similarly, PHP method \f[C]hasher()\f[R] \f[B]must\f[R] be called on the \f[C]CyberCache\f[R] instance before calling any method that will carry out a command requiring authentication.
.RE
.PP
Syntax:
.IP
.nf
\f[C]
HASHER [ xxhash | farmhash | spookyhash | murmurhash2 | murmurhash3 ]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
c3.session_hasher
c3.fpc_hasher
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
hasher
\f[R]
.fi
.SS \f[C]RESULT\f[R]
.PP
Unlike all other commands in the section (except \f[C]NEXT\f[R]), \f[C]RESULT\f[R] does not affect any subsequent commands; instead, it prints out portion of the result of last executed command that returned a list or a chunk of data.
.PP
Whenever a command returns a chunk of data, last line after printed out data is \f[C]Received <N> bytes; showing <M> bytes starting at <offset>.\f[R].
Likewise, when a command returns a list (counted or now), last line after printed out data is \f[C]Received <N> items; showing <M> items starting at <item\-index>.\f[R] If not all data chunk bytes or list items are displayed, the \f[C]RESULT\f[R] command can be used to view them.
.PP
Negative offset (\f[C]<from>\f[R]) means \f[I]from the end of buffer or list\f[R], negative length means \f[I]this many bytes before offset\f[R]; omitted offset means \f[I]from the very beginning of the buffer of list\f[R], while omitted length means \f[I]to the very end of the buffer or list\f[R].
However, there is a limit to how many bytes or list items this command will display, and it is hardcoded.
.PP
The \f[C]<from>\f[R] and \f[C]<length>\f[R] parameters used with the last invocation of \f[C]RESULT\f[R] are remembered by the console and affect what \f[C]NEXT\f[R] command would display.
Invocation of any command that returns a data chunk or a list resets them.
.PP
Syntax:
.IP
.nf
\f[C]
RESULT [ <from> [ <length> ]]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.SS \f[C]NEXT\f[R]
.PP
Just like \f[C]RESULT\f[R], \f[C]NEXT\f[R] does not affect any subsequent commands but just prints out portion of the result of last executed command that returned a list or a chunk of data.
It prints out \f[C]<length>\f[R] data bytes or list items right after the last portion printed by \f[C]RESULT\f[R] or \f[C]NEXT\f[R], whichever was executed last; if \f[C]RESULT\f[R] was not executed after a command that returned a data chunk or a list (and thus reset the offset), it would start at zero offset.
Omitting \f[C]<length>\f[R] means \f[I]same as the last used one\f[R].
It \f[I]is\f[R] allowed to execute \f[C]NEXT\f[R] command without executing \f[C]RESULT\f[R] first.
.PP
Syntax:
.IP
.nf
\f[C]
NEXT [ <length> ]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.SS \f[C]AUTORESULT\f[R]
.PP
Sets command execution result printing mode: what kind of results should be fully printed out automatically.
If executed without argument, displays currently active mode.
Available modes are:
.IP \[bu] 2
\f[C]simple\f[R] : print out all results except lists and byte buffers,
.IP \[bu] 2
\f[C]lists\f[R] : print out all results except byte buffers (the default),
.IP \[bu] 2
\f[C]all\f[R] : print out all types of results.
.PP
Here, \[lq]not printing out\[rq] a result means that console will only indicate that, say, an buffer with N bytes had been received, and \f[C]RESULT\f[R] (or \f[C]NEXT\f[R]) command should be used to display received strings.
.PP
Syntax:
.IP
.nf
\f[C]
AUTORESULT [ simple | lists | all ]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.SS \f[C]CHECKRESULT\f[R]
.PP
Checks that last response received from the server has specified type and, optionally, that it contains specified data.
If a \f[C]<string>\f[R]s are specified along with \f[C]error\f[R] or \f[C]string\f[R] type, checks that response string contains all specified substrings.
If \f[C]<element>\f[R]s are specified, checks that list response contains all given elements; matches must be exact, in that if, say, returned list has element \f[C]Cats\f[R], then \f[C]checkresult list Cat\f[R] would fail.
.PP
If \f[C]<offset>\f[R] \f[I]and\f[R] \f[C]<bytes>\f[R] are specified along with the \f[C]data\f[R] type, then this command will check that data response has \f[C]<bytes>\f[R] at offset \f[C]<offset>\f[R].
If \f[C]<bytes>\f[R] is specified as a binary string containing zero bytes (e.g.\ as \[lq]foo\[rs]00bar\[rq]), then only bytes before first zero byte will be compared.
If there is \f[C]\[at]\f[R] prefix before \f[C]<bytes>\f[R], then \f[C]<bytes>\f[R] will be treated as file name; the file will be loaded, and its contents will be used for comparison.
A sequence similar to the following can be used to test if a big data record was successfully stored and then retrieved from the server:
.IP
.nf
\f[C]
save my\-id \[at]my\-big\-data\-file.xml
checkresult ok
load my\-id
checkresult data 0 \[at]my\-big\-data\-file.xml
\f[R]
.fi
.PP
Syntax:
.IP
.nf
\f[C]
CHECKRESULT { ok | error [ <string1> [ <string2> [...]]] | string [ <string1> [ <string2> [...]]] |
  list [ <element1> [ <element2> [...]]] | data [ <offset> [\[at]]<bytes> ] }
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.SS \f[C]DISPLAY\f[R]
.PP
Controls output of \f[C]RESULT\f[R] and \f[C]NEXT\f[R] commands.
The \f[C]<lines\-per\-screen>\f[R] argument only affects \f[C]RESULT\f[R], only when it (the \f[C]RESULT\f[R] command) is used without arguments for the first time after some server command execution, and only if result contains a byte buffer or a list.
The \f[C]<bytes\-per\-line>\f[R] affects both \f[C]RESULT\f[R] and \f[C]NEXT\f[R], but only if result returned from the server is a byte array; note that all bytes are output twice: once as a two\-character hexadecimal value, and once as a pritable character, so large \f[C]<bytes\-per\-line>\f[R] values are not practical.
Finally, the \f[C]<non\-printable\-char>\f[R] specifies what should be printed if a byte in the received byte array does not represent a printable character (default is `.').
.PP
Syntax:
.IP
.nf
\f[C]
DISPLAY [ <lines\-per\-screen> [ <bytes\-per\-line> [ <non\-printable\-char> ]]]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.SS \f[C]PRINT\f[R]
.PP
Prints specified message.
Can be used in batch mode, when it\[cq]s necessary to inditate what file is being loaded (i.e.\ what type of configuration changes are being made), or that all previous commands in the file had been executed successfully.
The batch file can be loaded by \f[C]EXECUTE\f[R] command, or specified as a command line argument to the console application.
.PP
Syntax:
.IP
.nf
\f[C]
PRINT <message\-to\-display>
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.SS \f[C]EMULATE\f[R]
.PP
Compiles and sends server command irrespective of whether specified command ID is a valid one, and whether format of the command for specified ID (if it \f[I]happens\f[R] to be valid) is correct, thus allowing to test server responses to various invalid input.
.PP
In the below syntax diagram, first line represents either a single command ID, or a command descriptor.
In the descriptor, a password can be specified either as a (possibly empty) string, or \f[C]\-\f[R] (meaning \f[I]use currently active password\f[R]).
Payload should specified as a string (again, possibly empty); if it is prefixed with \f[C]\[at]\f[R], then the string is treated as file path that will be loaded and used as payload.
.PP
Remaining lines of the syntax diagram represent optional arguments; an argument can be an integer number, a string, or a list.
If a string \[lq]looks\[rq] like a number but respective argument should still be sent as a string, it should be prefixed with \f[C]%\f[R].
A list is a sequence of strings in square brackets separated with spaces; it is \f[I]not\f[R] necessary to prefix any strings comprising list with \f[C]%\f[R], they will all be sent as strings even if they \[lq]look\[rq] like numbers.
.PP
It is important that \f[C]{\f[R], \f[C]}\f[R], \f[C][\f[R], and \f[C]]\f[R] descriptor and list separators have spaces around them.
Say, entering \f[C]{36 }\f[R] or \f[C]{ 36}\f[R] instead of \f[C]{ 36 }\f[R] would result in parsing error, and the command will not be sent to the server.
.PP
Sintax:
.IP
.nf
\f[C]
EMULATE <id> | \[ga]{\[ga] <id> [ user | admin [ \[ga]\-\[ga] | <password> [ [\[ga]\[at]\[ga]]<payload> [ <check> ]]]] \[ga]}\[ga]
  [ <number> | <string> | \[ga]%\[ga]<number> | \[ga][\[ga] [ <string> [ <string> [...]]] \[ga]]\[ga]
    [ <number> | <string> | \[ga]%\[ga]<number> | \[ga][\[ga] [ <string> [ <string> [...]]] \[ga]]\[ga]
    [...]]]
\f[R]
.fi
.PP
PHP INI options:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Option name passed in option array to \f[C]c3_session()\f[R] / \f[C]c3_fpc()\f[R]:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.SS Information Commands
.PP
In order to execure any command in this category, authorization may or may not be necessary depending upon \f[C]use_info_password\f[R] option in server configuration file, which can take one of the following values:
.IP \[bu] 2
\f[C]none\f[R] : password is not necessary (the default),
.IP \[bu] 2
\f[C]user\f[R] : user password is required,
.IP \[bu] 2
\f[C]admin\f[R] : admin password is required.
.RS
.PP
\f[I]IMPORTANT\f[R]: console application does not \[lq]know\[rq] what value was given to the \f[C]use_info_password\f[R] in the server configuration file, so whenever an information command issued to the console, it authorizes it with the \[lq]strongest\[rq] password it received so far (i.e.\ if both \[lq]user\[rq] and \[lq]admin\[rq] passwords were specified using \f[C]USER\f[R] and \f[C]ADMIN\f[R] console commands [see below], respectively, console will be sending \[lq]admin\[rq] password with every command); this works because password type is sent with every command, and authorizing any command (any, not just informational) with \[lq]admin\[rq] password even if the command only requires \[lq]user\[rq] password is OK \[en] \f[I]provided that\f[R] correct \[lq]admin\[rq] password is indeed specified in server\[cq]s configuration file.
.RE
.SS \f[C]PING\f[R]
.PP
Simple server availability check, always responds with \f[C]OK\f[R] to a well\-formed command.
PHP method returns \f[C]true\f[R] on success, or \f[C]false\f[R] on error.
.PP
Console command:
.IP
.nf
\f[C]
[ USER ]
[ ADMIN ]
[ MARKER <boolean> ]
PING
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
bool c3_ping($resource)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR 0x01 [ PASSWORD ] [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
admin_password <password\-string>
use_info_password [ none | user | admin ]
\f[R]
.fi
.SS \f[C]CHECK\f[R]
.PP
Report results of last health check of the server, along with current load.
Meant be used to monitor server availability in highly loaded setups where \f[C]PING\f[R] is not enough.
On success, returns three integers; the first integer is percentage of \f[I]connection\f[R] threads that are currently busy processing requests (\f[C]100*<busy\-threads>/<total\-threads>\f[R], i.e.\ the number between 0 and 100), the second and third are numbers of warnings and non\-fatal errors that has occurred since server was started, respectively (actual errors are not returned, and has to be looked up in log file).
On error, PHP method returns empty array.
.PP
Console command:
.IP
.nf
\f[C]
[ USER ]
[ ADMIN ]
[ MARKER <boolean> ]
CHECK
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
array c3_check($resource)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR 0x02 [ PASSWORD ] [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- DATA HEADER { CHUNK(NUMBER) CHUNK(NUMBER) CHUNK(NUMBER) } [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
admin_password <password\-string>
use_info_password [ none | user | admin ]
\f[R]
.fi
.SS \f[C]INFO\f[R]
.PP
Prints out current status and usage information either for specified domains or, if domains are omitted, for all server domains.
This command does \f[I]not\f[R] print out configuration options; there\[cq]s \f[C]GET\f[R] command for that.
Likewise, it does \f[I]not\f[R] return any performance counters; if that is necessary, \f[C]STATS\f[R] command should be used.
.PP
The list returned by the server contains one element per parameter, with parameters and their values separated with \f[C]:\f[R] (space\-colon\-space); before printing them out, console figures out rightmost position of the colon, and outputs the list justified relative to the position of the colon.
If an parameter\[cq]s value is actually an array, it is reported as a string like \f[C][<val1>,<val2>,...<valN>]\f[R] and printed out by the console as\-is.
.PP
Console command:
.IP
.nf
\f[C]
[ USER ]
[ ADMIN ]
[ MARKER <boolean> ]
INFO [ GLOBAL | SESSION | FPC | ALL [ GLOBAL | SESSION | FPC | ALL [...]]]
\f[R]
.fi
.PP
PHP extension method (returns array on success, empty array on error):
.IP
.nf
\f[C]
array c3_info($resource, int $domain = C3_DOMAIN_ALL)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x10 [ PASSWORD ] CHUNK(NUMBER) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- LIST HEADER { PAYLOAD_INFO CHUNK(NUMBER) } PAYLOAD [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
admin_password <password\-string>
use_info_password [ none | user | admin ]
\f[R]
.fi
.SS \f[C]STATS\f[R]
.PP
Prints out performance counters either for specified domains or, if domains are omitted, for entire server and all its domains.
If argument is specified, only retrieves performance counters whose names match the mask (and, of course, which belong to specified domains).
The mask may contain arbirtary number of asterisks (\f[C]*\f[R]), which match any text so, for instance, the following requests are possible (matching is case\-insensitive):
.IP
.nf
\f[C]
stats                            (the first three examples are equivalent)
stats *
stats * all
stats *queue* session fpc
stats * global
stats *_pipeline_*
stats num_*
stats *events fpc
\f[R]
.fi
.PP
The list returned by the server contains one element per performance counter, with counter names and their values separated with \f[C]:\f[R] (colon\-space); before printing them out, console figures out rightmost position of the colon, and outputs the list justified relative to the position of the colon.
For some counters, separate values are reported for global, session, and FPC domains (if a counter is store\-specific, \[lq]global\[rq] value actually refers to tags).
If there are more than three values per counter, they denote numbers of times each tracked value was encountered (e.g.\ \[lq]1 4 3 5 0 3\[rq] means that value of \f[C]0\f[R] was encountered 1 time, value \f[C]1\f[R] 4 times, value \f[C]2\f[R] 3 times, etc.).
.RS
.PP
This command \f[I]requires instrumented version\f[R] of the CyberCache server, and will return error message if console or PHP extension is connected to production version of the CyberCache server.
.RE
.PP
Console command:
.IP
.nf
\f[C]
[ USER ]
[ ADMIN ]
[ MARKER <boolean> ]
STATS [ <mask> [ GLOBAL | SESSION | FPC | ALL [ GLOBAL | SESSION | FPC | ALL [...]]]]
\f[R]
.fi
.PP
PHP extension method (returns array on success, empty array on error):
.IP
.nf
\f[C]
array c3_stats($resource, int $domain = C3_DOMAIN_ALL, string $mask = \[dq]*\[dq])
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x11 [ PASSWORD ] CHUNK(NUMBER) CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- LIST HEADER { PAYLOAD_INFO CHUNK(NUMBER) } PAYLOAD [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
admin_password <password\-string>
use_info_password [ none | user | admin ]
\f[R]
.fi
.SS Administrative Commands
.PP
In order to execure any command in this category, it is necessary to enter administrator password first (using \f[C]ADMIN\f[R] auxiliary command) \[en] unless admin password is empty in the configuration file.
.SS \f[C]SHUTDOWN\f[R]
.PP
Shuts down the server \f[I]to which the console is currently connected\f[R].
.PP
Console command(s):
.IP
.nf
\f[C]
[ ADMIN ]
[ MARKER <boolean> ]
SHUTDOWN
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
bool c3_shutdown($resource)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR 0xF0 [ PASSWORD ] [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
admin_password <password\-string>
perf_shutdown_wait <duration>
perf_shutdown_final_wait <duration>
\f[R]
.fi
.SS \f[C]LOCALCONFIG\f[R]
.PP
Loads local (i.e.\ located on the computer where server console is running) configuration file and passes \f[I]its contents\f[R] to the CyberCache server for interpretation.
.PP
Options that are not specified in the file being loaded are not affected (i.e.\ will retain their values, either set by previously loaded configuration file [default, specified using command line, local, or remote], or defaults if no configuration file has set them during current session).
Therefore, it is entirely possible to have \[lq]small\[rq] config files that only change a particular set of options.
.RS
.PP
\f[B]IMPORTANT\f[R]: the following options
.IP \[bu] 2
\f[C]user_password\f[R]
.IP \[bu] 2
\f[C]admin_password\f[R]
.IP \[bu] 2
\f[C]bulk_password\f[R]
.IP \[bu] 2
\f[C]table_hash_method\f[R]
.IP \[bu] 2
\f[C]password_hash_method\f[R]
.IP \[bu] 2
\f[C]session_tables_per_store\f[R],
.IP \[bu] 2
\f[C]fpc_tables_per_store\f[R],
.IP \[bu] 2
\f[C]tags_tables_per_store\f[R], and
.IP \[bu] 2
\f[C]perf_num_internal_tag_refs\f[R]
.PP
in the configuration file being loaded will be ignored; this behavior is consistent with \f[C]SET\f[R] and \f[C]REMOTECONFIG\f[R] console commands and respective PHP API calls.
.RE
.RS
.PP
\f[B]VERY IMPORTANT\f[R]: if configuration file sent using \f[C]LOCALCONFIG\f[R] contains \f[C]include\f[R] statements, those statements will be executed \f[I]on the host that runs the server\f[R], which is most probabably not what one would expect or want.
.RE
.PP
\f[C]LOCALCONFIG\f[R] is a console / PHP API command (i.e.\ not a protocol command), in that it is the console (or PHP method) that loads configuration file into its buffer and then sends \f[C]SET\f[R] command to the server; from the server\[cq]s standpoint, there is no difference in interpreting a single name/value line of text, or a complete contents of a configuration file.
.PP
Console command(s):
.IP
.nf
\f[C]
[ ADMIN ]
[ MARKER <boolean> ]
LOCALCONFIG [ <path> ]
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
bool c3_local_config($resource, string $path)
\f[R]
.fi
.PP
Request sequence (identical to that of \f[C]SET\f[R] command):
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0xF6 [ PASSWORD ] CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
admin_password <password\-string>
The option(s) specified in the configuration file being loaded
\f[R]
.fi
.SS \f[C]REMOTECONFIG\f[R]
.PP
Passes path to a remote (i.e.\ located on the host where CyberCache server itself is running) configuration file to the CyberCache server for loading and interpretation.
If path is not specified, last configuration file loaded using \f[C]REMOTECONFIG\f[R] is assumed; if \f[C]REMOTECONFIG\f[R] with a valid path has not been executed yet \f[I]in this console\f[R], omitting path would result in error.
In other words, default path is a property of console, not server; so PHP API call does not have a default value for its parameter.
.PP
To locate the file, the server will use the same algorithm it uses to locate configuration file specified as command line argument; specifically:
.IP \[bu] 2
if path starts with either \f[C].\f[R] or \f[C]/\f[R], it will be used \[lq]as is\[rq] (note that backslash is not interpreted as path separator, even on Windows),
.IP \[bu] 2
otherwise, server searches \f[C]/etc/\f[R] path for configuration file,
.IP \[bu] 2
if the file is not found, server checks directory containing its executable,
.IP \[bu] 2
if the file is still not found, server checks current directory.
.PP
Options that are not specified in the file being loaded are not affected (i.e.\ will retain their values, either set by previously loaded configuration file [default, specified using command line, local, or remote], or defaults if no configuration file has set them during current session).
Therefore, it is entirely possible to have \[lq]small\[rq] config files that only change a particular set of options.
.RS
.PP
\f[B]IMPORTANT\f[R]: the following options
.IP \[bu] 2
\f[C]user_password\f[R]
.IP \[bu] 2
\f[C]admin_password\f[R]
.IP \[bu] 2
\f[C]bulk_password\f[R]
.IP \[bu] 2
\f[C]table_hash_method\f[R]
.IP \[bu] 2
\f[C]password_hash_method\f[R]
.IP \[bu] 2
\f[C]perf_num_internal_tag_refs\f[R]
.PP
in the configuration file being loaded will be ignored; this behavior is consistent with \f[C]SET\f[R] and \f[C]LOCALCONFIG\f[R] console commands and respective PHP API calls.
.RE
.PP
The CyberCache protocol command used for the implementation of \f[C]REMOTECONFIG\f[R] console command and \f[C]remoteConfig()\f[R] PHP API call is \f[C]LOADCONFIG\f[R].
.PP
Console command(s):
.IP
.nf
\f[C]
[ ADMIN ]
[ MARKER <boolean> ]
REMOTECONFIG [ <path> ]
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
bool c3_remote_config($resource, string $path)
\f[R]
.fi
.PP
Request sequence (\f[C]LOADCONFIG\f[R] command):
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0xF1 [ PASSWORD ] CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
admin_password <password\-string>
The option(s) specified in the configuration file being loaded
\f[R]
.fi
.SS \f[C]RESTORE\f[R]
.PP
Loads cache records stored in a session of FPC binlog file that is specified by name; current cache contents is not dropped, the server keeps working and servicing incoming requests.
.PP
Even though there are separate binlog (saving) services for session and FPC domains, binlog files themselves do not differ.
It is possible, for example, to configure the server to write session binlog to some \[lq]file.bin\[rq] with no binlog file for FPC domain, then re\-configure the service to not have session binlog file, but write FPC binlog to that same \[lq]file.bin\[rq].
If we then \f[C]RESTORE\f[R] from that file, binlog loader will first replay saved session records, and then FPC records.
So \f[C]RESTORE\f[R] command does not have any domain\-specific flavours.
.PP
Console command(s):
.IP
.nf
\f[C]
[ ADMIN ]
[ MARKER <boolean> ]
RESTORE <path>
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
bool c3_restore($resource, string $path)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0xF2 [ PASSWORD ] CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
admin_password <password\-string>
\f[R]
.fi
.SS \f[C]STORE\f[R]
.PP
Stores entire contents of the specified cache domain (or domains) to the database file.
If \f[C]path\f[R] refers to an existing file, it will be overwritten.
If first arguments is \f[C]all\f[R] (meaning both session and FPC domains), then all records will be saved to a single file.
If \f[C]path\f[R] does \f[I]not\f[R] contain forward slaches (`/'), then it will be prefixed with path to CyberCache\[cq]s data directory (usually \f[C]/var/lib/cybercache/\f[R]); otherwise, it will be used as\-is.
.PP
The \f[C]<user\-agent>\f[R] argument allows to filter out some records; CyberCache keeps track of user types that created each record, so it might make sense to, say, exclude session records created by bots, or FPC records created by unknown users.
The \f[C]<user\-agent>\f[R] specifies \[lq]lowest\[rq] user agent type whose records has to be preserved; for instance, specifying \f[C]warmer\f[R] will cause records created by cache warmer and regular users to be stored, while records created by unknown users and bots will be skipped.
Default is \f[C]unknown\f[R] (which essentially means \[lq]store all records\[rq]).
.PP
The \f[C]<sync\-mode>\f[R] argument controls synchronization during writing data to disk; available options are (in order of fastest but least reliable, to slowest but most reliable): \f[C]none\f[R] (the default), \f[C]data\-only\f[R], \f[C]full\f[R].
.RS
.PP
\f[I]IMPORTANT\f[R]: if you want to store session and FPC data using different sets of user agent and/or synchronization options, you\[cq]ll have to use \f[I]two\f[R] \f[C]STORE\f[R] commands.
And you\[cq]ll also have to use \f[B]different\f[R] file names for each of them, so that second command does not overwrite output of the first.
.RE
.PP
Files created using \f[C]STORE\f[R] command can then be loaded using \f[C]RESTORE\f[R].
There is also set of server configuration options that allow to configure the server to save databases on shutdown, and the re\-load them on startup; see \f[C]session_db_file\f[R], \f[C]fpc_db_file\f[R] and related options\[cq] description in the main server configuration file.
.PP
Console command(s):
.IP
.nf
\f[C]
[ ADMIN ]
[ MARKER <boolean> ]
STORE { all | session | fpc } <path> [ { unknown | bot | warmer | user } [ { none | data\-only | full ] ]
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
bool c3_store($resource, int $domain, string $path, int $ua = C3_UA_UNKNOWN, int $sync = C3_SYNC_NONE)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0xF3 [ PASSWORD ] CHUNK(NUMBER) CHUNK(STRING) CHUNK(NUMBER) CHUNK(NUMBER) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
admin_password <password\-string>
\f[R]
.fi
.SS \f[C]GET\f[R]
.PP
Get current value of any configuration option other than \f[C]admin_password\f[R], \f[C]user_password\f[R], or \f[C]bulk_password\f[R].
It is possible to request values of more then one variable.
All values are always returned as strings; it is up to the caller to parse them into ints etc.
as/if needed (though in PHP that is rarely necessary).
.RS
.PP
It is possible to use arbitrary number of asterisks (\f[C]*\f[R]) in the name of the option, thus retrieving values of all options that match the wildcard.
For instance, it is possible to retrieve options values like this:
.IP
.nf
\f[C]
\- get *
\- get perf_*
\- get *read*
\- get perf_*replicator*
\- get *_capacity
\f[R]
.fi
.PP
It is also possible to specify more than one mask per request.
.RE
.PP
Configuration option values are reported in the same format as that of the \f[C]INFO\f[R] and \f[C]STATS\f[R] commands.
.PP
Not all options\[cq] values can be retrieved using \f[C]GET\f[R]; for instance, because of the asynchronous nature of CyberCache subsystems, only [most] numeric values can be retrieved, but not strings: it is not possible to request current log or binlog file name, or rotation path, for instance \[en] that would require locking respective subsystem, and CyberCache is architected in a way that avoids locking if at all possible.
Some numeric values \f[I]could\f[R] be retrieved, but it\[cq]s not clear how to represent them; as an example, \f[C]perf_fpc_init_table_capacity\f[R] sets \f[I]initial\f[R] capacity of all hash tables of the FPC object store, but by the time of \f[C]GET\f[R] request those tables would most likely have different capacities, and there can be up to \f[C]256\f[R] hash tables in the FPC store (in \f[I]Enterprise\f[R] edition).
Passwords will not be retrieved for obvious reasons (in fact, they are not stored even internally: only their hash codes are).
Therefore:
.RS
.PP
Options whose values cannot be retrieved will have \f[B]value could not be retrieved\f[R] against their names; they won\[cq]t be completely omitted so that not to confuse the user (especially if options were queried using a mask).
.RE
.PP
In addition to options that can be set in the configuration file or command line, \f[C]GET\f[R] can also fetch one option that can \f[I]not\f[R] be set; namely, \f[C]version\f[R].
.PP
Console command(s):
.IP
.nf
\f[C]
[ ADMIN ]
[ MARKER <boolean> ]
GET <configuration\-option> [ <configuration\-option> [ ... ]]
\f[R]
.fi
.PP
PHP extension method (returns empty array on errors):
.IP
.nf
\f[C]
array c3_get($resource, string ... $option_names)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0xF5 [ PASSWORD ] CHUNK(LIST) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- LIST HEADER { [ PAYLOAD_INFO ] CHUNK(NUMBER) } [ PAYLOAD ] [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
admin_password <password\-string>
The option(s) being fetched
\f[R]
.fi
.SS \f[C]SET\f[R]
.PP
Set new value of any configuration option.
Both console and PHP method concatenate option name and value with a space (\[dq] \[dq]) and send them to the server as a single string; if option value is an empty string \f[I]or\f[R] starts with a space, it will be quoted.
.RS
.PP
\f[B]IMPORTANT\f[R]: an attempt to set any of the following options
.IP \[bu] 2
\f[C]user_password\f[R]
.IP \[bu] 2
\f[C]admin_password\f[R]
.IP \[bu] 2
\f[C]bulk_password\f[R]
.IP \[bu] 2
\f[C]table_hash_method\f[R]
.IP \[bu] 2
\f[C]password_hash_method\f[R]
.IP \[bu] 2
\f[C]perf_num_internal_tag_refs\f[R]
.PP
will be ignored; this behavior is consistent with \f[C]LOCALCONFIG\f[R] and \f[C]REMOTECONFIG\f[R] console commands and respective PHP API calls.
.RE
.PP
Console command(s):
.IP
.nf
\f[C]
[ ADMIN ]
[ MARKER <boolean> ]
SET <configuration\-option> <new\-value>
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
bool c3_set($resource, string $option_name, $option_value)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0xF6 [ PASSWORD ] CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
admin_password <password\-string>
The option being changed
\f[R]
.fi
.SS \f[C]LOG\f[R]
.PP
Log provided message to the server log.
The command is actually passed to (and executed by) the server; its output is \f[I]not\f[R] echoed to the console.
Current log level of the server does \f[I]not\f[R] affect this command, it will always work (unless, of course, logging is disabled in the configuration).
.PP
Console command(s):
.IP
.nf
\f[C]
[ ADMIN ]
[ MARKER <boolean> ]
LOG <message>
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
bool c3_log($resource, string $message)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0xFA [ PASSWORD ] CHUNK(STRING) ] } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
admin_password <password\-string>
log_file_name <file\-path>
log_file_max_size <file_size>
\f[R]
.fi
.SS \f[C]ROTATE\f[R]
.PP
Rotate log file that corresponds to the service specified as argument; file rotation will be forced even if log file size did not reach rotation threshold specified in the configuration.
Unlike with \f[C]INFO\f[R] or \f[C]STATS\f[R] commands, not specifying domain argument causes regular log file (i.e.\ not s session or FPC binlog) rotation.
To force rotation of all log files, it is necessary to list all domains/services (\f[C]LOG\f[R], \f[C]SESSIONBINLOG\f[R], \f[C]FPCBINLOG\f[R]).
.PP
Console command(s):
.IP
.nf
\f[C]
[ ADMIN ]
[ MARKER <boolean> ]
ROTATE [ LOG | SESSIONBINLOG | FPCBINLOG [ LOG | SESSIONBINLOG | FPCBINLOG [...]]]
\f[R]
.fi
.PP
PHP extension method (here, \f[C]DOMAIN_GLOBAL\f[R] stands for regular log file):
.IP
.nf
\f[C]
bool c3_log($resource, int $domain = C3_DOMAIN_GLOBAL)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0xFB [ PASSWORD ] CHUNK(NUMBER) ] } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
admin_password <password\-string>
log_file_name <file\-path>
session_binlog_file_name <file\-path>
fpc_binlog_file_name <file\-path>
\f[R]
.fi
.SS Session Cache Commands
.PP
In order to execure any command in this category, it is necessary to enter user password (using \f[C]USER\f[R] auxiliary command) first \[en] unless user password is empty in the server configuration file.
.SS \f[C]READ\f[R]
.PP
Fetches session cache entry.
Console prints out \f[I]uncompressed\f[R] fetched data as text, replacing non\-printable characters with dots.
When working with cache through console, user agent type (the \f[C]CHUNK(NUMBER)\f[R] passed to to the server, usually the result of analyzing \f[C]user_agent\f[R] field of the request passed to the PHP method) is the one specified using \f[C]USERAGENT\f[R] console command.
.RS
.PP
An attempt to fetch a non\-existent session cache entry does \f[I]not\f[R] result in an error: in such a case, server returns \f[C]Ok\f[R] response, \f[C]read()\f[R] returns an empty string (which is consistent with \f[C]SessionHandlerInterface::read()\f[R] calling convention), and \f[C]getErrorMessage()\f[R] returns an empty string.
.RE
.PP
If specified session record exists and not marked as \[lq]deleted\[rq], then if it had been expired, it will be \[lq]revived\[rq] by setting its expiration timestamp to current time plus \f[C]session_read_extra_lifetime[<user\-agent>]\f[R], and returned by the server.
If \f[C]session_eviction_mode\f[R] is \f[I]not\f[R] \f[C]expiration\-lru\f[R] or \f[C]strict\-expiration\-lru\f[R], then record\[cq]s expiration time will be adjusted as if it was expired (but only if \f[C]session_read_extra_lifetime\f[R] is bigger than remaining lifetime).
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ USERAGENT [ <agent\-type> ]]
[ MARKER <boolean> ]
READ <entry\-id>
\f[R]
.fi
.PP
PHP extension method (user agent is taked from resource):
.IP
.nf
\f[C]
string c3_read($resource, string $entry_id)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x21 [ PASSWORD ] CHUNK(STRING) CHUNK(NUMBER)
  [ CHUNK(NUMBER) ] } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- DATA HEADER { PAYLOAD_INFO } PAYLOAD [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
session_read_extra_lifetime <duration> [ <duration> [...]]
session_eviction_mode { strict\-expiration\-lru | expiration\-lru | lru | strict\-lru }
\f[R]
.fi
.SS \f[C]WRITE\f[R]
.PP
Stores session cache entry.
When working with cache through console, user agent type (the \f[C]CHUNK(NUMBER)\f[R] passed to to the server, usually the result of analyzing \f[C]user_agent\f[R] field of the request passed to the PHP method) is the one specified using \f[C]USERAGENT\f[R] console command.
Return value of the PHP method is consistent with that of \f[C]SessionHandlerInterface::write()\f[R].
.PP
Console takes \f[C]lefitime\f[R] field from the value set by \f[C]LIFETIME\f[R] auxiliary command: \f[C]0\f[R] means \[lq]infinite\[rq], \f[C]\-1\f[R] means \[lq]use default\[rq] (calculated using the algorithm described below), and any other positive integer value is called \[lq]specific lifetime\[rq] and is used as\-is.
.PP
If lifetime of \f[C]\-1\f[R] is send to the server as part of the command, then during first \f[C]session_first_write_num\f[R] writes to a session record, the lifetime of the record is set to \f[C]session_first_write_lifetime\f[R] plus the difference between \f[C]session_default_lifetime\f[R] and \f[C]session_first_write_lifetime\f[R] divided by \f[C]session_first_write_num\f[R], times number number of previous writes; that is, on first write it is set to \f[C]session_first_write_lifetime\f[R], and then with each subsequent write it increases until it reaches \f[C]session_default_lifetime\f[R] during write number \f[C]session_first_write_num+1\f[R], and then platoes.
.RS
.PP
\f[B]IMPORTANT\f[R]: if very first character of argument is \f[C]\[at]\f[R], then the rest of it is treated as name of the file that will be loaded, compressed, and sent to the server as payload.
If very first character of literal session data entered using console has to be \f[C]\[at]\f[R], it has to be put into a file.
If session data specified as a string happens to have zero bytes, it would get truncated at first zero byte upon sending; neither data loaded from file, nor PHP API have this restriction, so if it is necessary to send data with zero bytes in it using console, the data should be put into a file first.
.RE
.RS
.PP
If session data is specified as a zero\-length string (\[cq]\[cq]), or an empty file, the command will remove respective session record.
.RE
.PP
When sending data to the server from console, session entry data should of course be entered in uncompressed form; the console will compress it before sending to the server using compressor specified with \f[C]COMPRESSOR\f[R] command.
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ USERAGENT [ <agent\-type> ]]
[ LIFETIME [ <duration> ]]
[ COMPRESSOR <compressor> ]
[ MARKER <boolean> ]
WRITE <entry\-id> [\[at]]<session\-data>
\f[R]
.fi
.PP
PHP extension method (user agent is taked from resource):
.IP
.nf
\f[C]
bool c3_write($resource, string $entry_id, int $lifetime, string $entry_data)
\f[R]
.fi
.PP
Request sequence (first number is user agent, second is lifetime):
.IP
.nf
\f[C]
DESCRIPTOR HEADER {
  0x22 [ PASSWORD ] [ PAYLOAD_INFO ] CHUNK(STRING) CHUNK(NUMBER)
    CHUNK(NUMBER) [ CHUNK(NUMBER) ] } [ PAYLOAD ] [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
DESCRIPTOR HEADER {
  0x22 [ PASSWORD ] [ PAYLOAD_INFO ] CHUNK(STRING) CHUNK(NUMBER)
    CHUNK(NUMBER) [ CHUNK(NUMBER) ] } [ PAYLOAD ] [ MARKER ]
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
session_first_write_lifetime <duration> [ <duration> [...]]
session_first_write_num <duration> [ <duration> [...]]
session_default_lifetime <duration> [ <duration> [...]]
\f[R]
.fi
.SS \f[C]DESTROY\f[R]
.PP
Deletes session cache entry.
Return value of the PHP method is consistent with that of \f[C]SessionHandlerInterface::destroy()\f[R]; \f[C]false\f[R] is returned only if there was an error; if the record is not found, return value is still \f[C]true\f[R].
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ MARKER <boolean> ]
DESTROY <entry\-id>
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
bool c3_destroy($resource, string $entry_id)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x23 [ PASSWORD ] CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x23 [ PASSWORD ] CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
\f[R]
.fi
.SS \f[C]GC\f[R]
.PP
Delete session cache entries that had not been updated during specified number of seconds.
Return value of the PHP method is consistent with that of \f[C]SessionHandlerInterface::gc()\f[R].
If \f[C]session_eviction_mode\f[R] is set to \f[C]strict\-lru\f[R], this request will be ignored; the server will just return \f[C]Ok\f[R].
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ MARKER <boolean> ]
GC <duration>
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
bool c3_gc($resource, int $number_of_seconds)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x24 [ PASSWORD ] CHUNK(NUMBER) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication (these commands are written to binlog as garbage collection progresses):
.IP
.nf
\f[C]
[ DESCRIPTOR HEADER { 0x23 [ PASSWORD ] CHUNK(STRING) } [ MARKER ]
  [ DESCRIPTOR HEADER { 0x23 [ PASSWORD ] CHUNK(STRING) } [ MARKER ] [ ... ]]]
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
session_eviction_mode { strict\-expiration\-lru | expiration\-lru | lru | strict\-lru }
\f[R]
.fi
.SS Full Page Cache Commands
.PP
In order to execure any command in this category, it is necessary to enter user password (using \f[C]USER\f[R] auxiliary command) first \[en] unless user password is empty in the server configuration file.
.PP
CyberCache has to support methods found in
.IP "1." 3
\f[C]Zend_Cache_Backend\f[R] class,
.IP "2." 3
\f[C]Zend_Cache_Backend_Interface\f[R] interface and
.IP "3." 3
\f[C]Zend_Cache_Backend_ExtendedInterface\f[R].
.PP
The first of the three does not require any special support; in the Redis\-based implementation of the FPC, only few methods are overwritten, and even they either do not require interactions with cache store, or do something that is already implemented in the parent class; like, say, \f[C]isAutomaticCleaningAvailable()\f[R] returning \f[C]true\f[R].
So the real job is to support methods found in \f[C]Zend_Cache_Backend_Interface\f[R] and \f[C]Zend_Cache_Backend_ExtendedInterface\f[R] interfaces.
.SS \f[C]LOAD\f[R]
.PP
Fetches FPC entry.
Console prints out \f[I]uncompressed\f[R] fetched data as text, replacing non\-printable characters with dots.
.PP
When working with cache through console, bot type (the \f[C]CHUNK(NUMBER)\f[R] passed to to the server, usually the result of analyzing \f[C]user_agent\f[R] field of the request passed to the PHP method) is the one specified using \f[C]USERAGENT\f[R] console command (\f[C]user\f[R] by default).
.RS
.PP
An attempt to fetch a non\-existent FPC entry does \f[I]not\f[R] result in an error: in such a case, server returns \f[C]Ok\f[R] response, \f[C]load()\f[R] returns \f[C]false\f[R] (which is consistent with \f[C]Zend_Cache_Backend_Interface::load()\f[R] calling convention), and \f[C]getErrorMessage()\f[R] returns an empty string.
.RE
.PP
If specified FPC record exists and not marked as \[lq]deleted\[rq], then if it had been expired, it will be \[lq]revived\[rq] by setting its expiration timestamp to current time plus \f[C]fpc_read_extra_lifetime[<user\-agent>]\f[R], and returned by the server.
If \f[C]fpc_eviction_mode\f[R] is \f[I]not\f[R] \f[C]expiration\-lru\f[R] or \f[C]strict\-expiration\-lru\f[R], then record\[cq]s expiration time will be adjusted as if it was expired (but only if \f[C]fpc_read_extra_lifetime\f[R] is bigger than remaining lifetime).
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ USERAGENT [ <agent\-type> ]]
[ MARKER <boolean> ]
LOAD <entry\-id>
\f[R]
.fi
.PP
PHP extension method (user agent is taked from resource):
.IP
.nf
\f[C]
string c3_load($resource, string $entry_id)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x41 [ PASSWORD ] CHUNK(STRING) CHUNK(NUMBER) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- DATA HEADER { PAYLOAD_INFO } PAYLOAD [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
fpc_read_extra_lifetime <duration> [ <duration> [...]]
fpc_eviction_mode { strict\-expiration\-lru | expiration\-lru | lru | strict\-lru }
\f[R]
.fi
.SS \f[C]TEST\f[R]
.PP
Checks if specified FPC entry exists, returns \f[C]Ok\f[R] (not error message) if it doesn\[cq]t.
PHP method \f[C]test()\f[R] returns \f[C]false\f[R] is the record does not exist, or last modification timestamp if it does (which is consistent with \f[C]Zend_Cache_Backend_Interface::test()\f[R] calling convention).
.PP
When working with cache through console, bot type (the \f[C]CHUNK(NUMBER)\f[R] passed to to the server, usually the result of analyzing \f[C]user_agent\f[R] field of the request passed to the PHP method) is the one specified using \f[C]USERAGENT\f[R] console command (\f[C]user\f[R]by default).
.PP
If specified FPC record exists and not marked as \[lq]deleted\[rq], then if it had been expired, it will be \[lq]revived\[rq] by setting its expiration timestamp to current time plus \f[C]fpc_read_extra_lifetime[<user\-agent>]\f[R], and returned by the server.
If \f[C]fpc_eviction_mode\f[R] is \f[I]not\f[R] \f[C]expiration\-lru\f[R] or \f[C]strict\-expiration\-lru\f[R], then record\[cq]s expiration time will be adjusted as if it was expired (but only if \f[C]fpc_read_extra_lifetime\f[R] is bigger than remaining lifetime).
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ USERAGENT [ <agent\-type> ]]
[ MARKER <boolean> ]
TEST <entry\-id>
\f[R]
.fi
.PP
PHP extension method (user agent is taked from resource):
.IP
.nf
\f[C]
int c3_test($resource, string $entry_id)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x42 [ PASSWORD ] CHUNK(STRING) CHUNK(NUMBER) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- DATA HEADER { CHUNK(NUMBER) } [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
fpc_read_extra_lifetime <duration> [ <duration> [...]]
fpc_eviction_mode { strict\-expiration\-lru | expiration\-lru | lru | strict\-lru }
\f[R]
.fi
.SS \f[C]SAVE\f[R]
.PP
Stores data chunk into specified FPC entry.
When working with cache through console:
.IP \[bu] 2
bot type (the first \f[C]CHUNK(NUMBER)\f[R] passed to to the server, usually the result of analyzing \f[C]user_agent\f[R] field of the request passed to the PHP method) is the one specified using \f[C]USERAGENT\f[R] console command (\f[C]user\f[R] by default),
.IP \[bu] 2
tags (the \f[C]CHUNK(LIST)\f[R] passed to the server) are the ones entered using \f[C]TAGS\f[R] console command; empty list by default,
.IP \[bu] 2
lefitime (the last \f[C]CHUNK(NUMBER)\f[R] passed to the server) is the one previously specified using \f[C]LIFETIME\f[R] console command; default is \f[C]\-1\f[R], meaning the lifetime specified for \f[C]fpc_default_lifetime\f[R] in the configuration file; zero lifetime means \[lq]infinite\[rq] and is implemented by setting expiration time for the record to the maximum possible timestamp.
.PP
PHP method \f[C]save()\f[R] returns \f[C]true\f[R] on success or \f[C]false\f[R] on error (which is consistent with \f[C]Zend_Cache_Backend_Interface::save()\f[R] calling convention).
.RS
.PP
\f[B]IMPORTANT\f[R]: if very first character of argument is \f[C]\[at]\f[R], then the rest of it is treated as name of the file that will be loaded, compressed, and sent to the server as payload.
If very first character of literal FPC entry data entered using console has to be \f[C]\[at]\f[R], it has to be put into a file.
If session data specified as a string happens to have zero bytes, it would get truncated at first zero byte upon sending; neither data loaded from file, nor PHP API have this restriction, so if it is necessary to send data with zero bytes in it using console, the data should be put into a file first.
.RE
.RS
.PP
If FPC data is specified as a zero\-length string (\[cq]\[cq]), or an empty file, the command will remove respective FPC record.
.RE
.PP
When sending data to the server from console, FPC entry data should of course be entered in uncompressed form; the console will compress it before sending to the server using compressor specified with \f[C]COMPRESSOR\f[R] command.
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ USERAGENT [ <agent\-type> ]]
[ LIFETIME [ <duration> ]]
[ TAGS [ <tag> [ <tag> [[ ... ]]]]]
[ ADDTAGS  <tag> [ <tag> [[ ... ]]]]
[ REMOVETAGS  <tag> [ <tag> [[ ... ]]]]
[ COMPRESSOR <compressor> ]
[ MARKER <boolean> ]
SAVE <entry\-id> [\[at]]<entry\-data>
\f[R]
.fi
.PP
PHP extension method (user agent is taked from resource):
.IP
.nf
\f[C]
bool c3_save($resource, string $entry_id, int $lifetime,
  array $tags, string $entry_data)
\f[R]
.fi
.PP
Request sequence (first number is user agent, second is lifetime):
.IP
.nf
\f[C]
DESCRIPTOR HEADER 0x43 {
  [ PASSWORD ] [ PAYLOAD_INFO ] CHUNK(STRING) CHUNK(NUMBER) CHUNK(NUMBER) CHUNK(LIST)
  } [ PAYLOAD ] [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
DESCRIPTOR HEADER 0x43 {
  [ PASSWORD ] [ PAYLOAD_INFO ] CHUNK(STRING) CHUNK(NUMBER) CHUNK(NUMBER) CHUNK(LIST)
  } [ PAYLOAD ] [ MARKER ]
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
fpc_default_lifetime <duration> [ <duration> [...]]
fpc_max_lifetime <duration> [ <duration> [...]]
perf_num_internal_tags_per_page <num\-tags>
\f[R]
.fi
.SS \f[C]REMOVE\f[R]
.PP
Deletes specified FPC entry.
PHP method \f[C]remove()\f[R] returns \f[C]true\f[R] on success or \f[C]false\f[R] on error (which is consistent with \f[C]Zend_Cache_Backend_Interface::remove()\f[R] calling convention).
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ MARKER <boolean> ]
REMOVE <entry\-id>
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
bool c3_remove($resource, string $entry_id)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x44 [ PASSWORD ] CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x44 [ PASSWORD ] CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
\f[R]
.fi
.SS \f[C]CLEAN\f[R]
.PP
Deletes specified FPC entries.
.PP
PHP method \f[C]clean()\f[R] receives one of the following strings as mode:
.IP \[bu] 2
\f[C]all\f[R] : remove all cache entries,
.IP \[bu] 2
\f[C]old\f[R] : remove old cache entries (do garbage collection),
.IP \[bu] 2
\f[C]matchingTag\f[R] : remove entries that match all the tags passed as second argument,
.IP \[bu] 2
\f[C]notMatchingTag\f[R] : remove entries that do not match any of the tags passed as second argument,
.IP \[bu] 2
\f[C]matchingAnyTag\f[R] : remove entries that match at least one of the tags passed as second argument.
.PP
If \f[C]fpc_eviction_mode\f[R] is set to \f[C]lru\-strict\f[R], \f[C]CLEAN\f[R] request with \f[C]old\f[R] mode will do nothing, the server will simply return \f[C]true\f[R].
.PP
In \f[C]all\f[R] and \f[C]old\f[R] modes, PHP method does not accept tags, even as an empty array; the argument in these modes must be either \f[C]NULL\f[R], or completely omitted.
In other modes, a \f[C]NULL\f[R] or omitted list is treated as an empty one.
.PP
The \f[C]clean()\f[R] method returns \f[C]true\f[R] on success or \f[C]false\f[R] on error (which is consistent with \f[C]Zend_Cache_Backend_Interface::clean()\f[R] calling convention).
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ MARKER <boolean> ]
CLEAN { all | old | matchall | matchnot | matchany } [ <tag> [ <tag> [ ... ]]]
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
bool c3_clean($resource, string $mode, array $tags = null)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x45 [ PASSWORD ] CHUNK(NUMBER) [ CHUNK(LIST) ] } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication (individual commands are written to binlog as garbage collection progresses):
.IP
.nf
\f[C]
[ DESCRIPTOR HEADER { 0x44 [ PASSWORD ] CHUNK(STRING) } [ MARKER ]
  [ DESCRIPTOR HEADER { 0x44 [ PASSWORD ] CHUNK(STRING) } [ MARKER ] [ ... ]]]
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
fpc_eviction_mode { strict\-expiration\-lru | expiration\-lru | lru | strict\-lru }
\f[R]
.fi
.SS \f[C]GETIDS\f[R]
.PP
Returns list of IDs of all existing FPC entries.
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ MARKER <boolean> ]
GETIDS
\f[R]
.fi
.PP
PHP extension method (returns empty array on errors):
.IP
.nf
\f[C]
array c3_get_ids($resource)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR 0x61 [ PASSWORD ] [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- LIST HEADER { [ PAYLOAD_INFO ] CHUNK(NUMBER) } [ PAYLOAD ] [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
\f[R]
.fi
.SS \f[C]GETTAGS\f[R]
.PP
Returns list of all tags that have at least one FPC record associated with them.
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ MARKER <boolean> ]
GETTAGS
\f[R]
.fi
.PP
PHP extension method (returns empty array on errors):
.IP
.nf
\f[C]
array c3_get_tags($resource)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR 0x62 [ PASSWORD ] [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- LIST HEADER { [ PAYLOAD_INFO ] CHUNK(NUMBER) } [ PAYLOAD ] [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
\f[R]
.fi
.SS \f[C]GETIDSMATCHINGTAGS\f[R]
.PP
Returns list of record IDs that are tagged with \f[I]all\f[R] specified tags.
Callers can pass a string to the PHP method instead of an array with a single element.
.RS
.PP
\f[I]NOTE\f[R]: Redis\-base implementation performs intersection of all tags passed to this method when retrieving IDs; the \f[C]matchingTag\f[R] mode of the \f[C]CLEAN\f[R] method in Redis\-based implementation calls \f[C]GETIDSMATCHINGTAGS\f[R] and then deletes cache entries with returned IDs.
.RE
.PP
If empty array is passed, PHP method immediately returns empty array without calling the server.
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ MARKER <boolean> ]
GETIDSMATCHINGTAGS [ <tag> [ <tag> [ ... ]]]
\f[R]
.fi
.PP
PHP extension method (returns empty array on errors):
.IP
.nf
\f[C]
array c3_get_ids_matching_tags($resource, $tags)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x63 [ PASSWORD ] CHUNK(LIST) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- LIST HEADER { [ PAYLOAD_INFO ] CHUNK(NUMBER) } [ PAYLOAD ] [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
\f[R]
.fi
.SS \f[C]GETIDSNOTMATCHINGTAGS\f[R]
.PP
Returns list of record IDs that are \f[I]not\f[R] tagged with \f[I]all\f[R] specified tags.
That is, if a record is not tagged at all, of if it is only tagged with some tags but \f[I]not\f[R] with any of the specified ones, it \f[I]will\f[R] be returned.
Callers can pass a string to the PHP method instead of an array with a single element.
.RS
.PP
\f[I]NOTE\f[R]: Redis\-base implementation performs difference between the list of all object IDs and all tags passed to this method; the \f[C]notMatchingTag\f[R] mode of the \f[C]CLEAN\f[R] method in Redis\-based implementation calls \f[C]GETIDSNOTMATCHINGTAGS\f[R] and then deletes cache entries with returned IDs.
.RE
.PP
If empty array is passed, PHP method calls server with an empty list, but server processes it as if it was a \f[C]GETIDS\f[R] request (returning \f[I]all\f[R] active entries).
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ MARKER <boolean> ]
GETIDSNOTMATCHINGTAGS [ <tag> [ <tag> [ ... ]]]
\f[R]
.fi
.PP
PHP extension method (returns empty array on errors):
.IP
.nf
\f[C]
array c3_get_ids_not_matching_tags($resource, $tags)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x64 [ PASSWORD ] CHUNK(LIST) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- LIST HEADER { [ PAYLOAD_INFO ] CHUNK(NUMBER) } [ PAYLOAD ] [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
\f[R]
.fi
.SS \f[C]GETIDSMATCHINGANYTAGS\f[R]
.PP
Returns list of record IDs that are tagged with \f[I]any\f[R] of the specified tags.
That is, if a record is tagged with at least one of the specified tags, it \f[I]will\f[R] be returned.
Callers can pass a string to the PHP method instead of an array with a single element.
.RS
.PP
\f[I]NOTE\f[R]: Redis\-base implementation performs union between all tags passed to this method; the \f[C]matchingAnyTag\f[R] mode of the \f[C]CLEAN\f[R] method in Redis\-based implementation calls \f[C]GETIDSMATCHINGANYTAGS\f[R] and then deletes cache entries with returned IDs.
.RE
.PP
If empty array is passed, PHP method immediately returns an empty list without calling the server.
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ MARKER <boolean> ]
GETIDSMATCHINGANYTAGS [ <tag> [ <tag> [ ... ]]]
\f[R]
.fi
.PP
PHP extension method (returns empty array on errors):
.IP
.nf
\f[C]
array c3_get_ids_matching_any_tags($resource, $tags)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x65 [ PASSWORD ] CHUNK(LIST) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- LIST HEADER { [ PAYLOAD_INFO ] CHUNK(NUMBER) } [ PAYLOAD ] [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
\f[R]
.fi
.SS \f[C]GETFILLINGPERCENTAGE\f[R]
.PP
Returns filling percentage of the FPC store, as an integer number between 0 and 100.
If memory quota is not set for the FPC domain (or an error is returned), reported percentage is 0.
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ MARKER <boolean> ]
GETFILLINGPERCENTAGE
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
int c3_get_filling_percentage($resource)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR 0x67 [ PASSWORD ] [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- DATA HEADER { CHUNK(NUMBER) } [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
\f[R]
.fi
.SS \f[C]GETMETADATAS\f[R]
.PP
Returns metadata associated with an FPC entry.
If the entry does not exist, server returns \f[C]Ok\f[R] and PHP method returns \f[C]false\f[R].
If the entry does exist, and is associated with \f[C]N\f[R] tags, then server response contains expiration time and last modification time (numbers of seconds since January 1st 1970), and a list with \f[C]N\f[R] strings in its header.
The PHP method returns associative array with \f[C]expire\f[R], \f[C]mtime\f[R], and \f[C]tags\f[R] entries, where \f[C]tags\f[R] element is a regular, non\-associative array of strings.
.PP
If an FPC record had been expired but had not been deleted yet, it will be \[lq]revived\[rq] by setting its expiration timestamp to current time plus \f[C]fpc_read_extra_lifetime[<user\-agent>]\f[R], and returned by the server.
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ MARKER <boolean> ]
GETMETADATAS <entry\-id>
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
array c3_get_metadatas($resource, string $entry_id)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x68 [ PASSWORD ] CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
N/A
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- DATA HEADER { CHUNK(NUMBER) CHUNK(NUMBER) CHUNK(LIST) } [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
fpc_read_extra_lifetime <duration> [ <duration> [...]]
fpc_eviction_mode { strict\-expiration\-lru | expiration\-lru | lru | strict\-lru }
\f[R]
.fi
.SS \f[C]TOUCH\f[R]
.PP
Adds extra lifetime to specified entry.
If the entry does not exist, the server will return error message, and PHP method will return \f[C]false\f[R].
If resulting lifitime exceeds that set with the \f[C]fpc_max_lifetime\f[R] option, lifetime will be set to current plus \f[C]fpc_max_lifetime\f[R].
If the entry does exist and setting new expiration time was successful, then server returns \f[C]Ok\f[R], and PHP method will return \f[C]true\f[R].
.RS
.PP
\f[I]NOTE\f[R]: if record\[cq]s lifetime was set to \f[C]infinite\f[R] by \f[C]SAVE\f[R] command, it will not be affected by \f[C]TOUCH\f[R]; the server will still return \f[C]Ok\f[R].
.RE
.PP
The server first calculates remaining TTL by subtracting current time from the expiration time that is in effect as of the time of the request; if the remaining TTL is negative (i.e.\ the record has expired), then it is set to zero.
New expiration time is then set to current time plus remaining TTL plus specified extra lifetime.
.PP
Console command(s):
.IP
.nf
\f[C]
[ USER ]
[ MARKER <boolean> ]
TOUCH <entry\-id> <extra\-lifetime>
\f[R]
.fi
.PP
PHP extension method:
.IP
.nf
\f[C]
bool c3_touch($resource, string $entry_id, int $extra_lifetime)
\f[R]
.fi
.PP
Request sequence:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x69 [ PASSWORD ] CHUNK(STRING) CHUNK(NUMBER) } [ MARKER ]
\f[R]
.fi
.PP
Binlog / replication:
.IP
.nf
\f[C]
DESCRIPTOR HEADER { 0x69 [ PASSWORD ] CHUNK(STRING) CHUNK(NUMBER) } [ MARKER ]
\f[R]
.fi
.PP
Server response:
.IP
.nf
\f[C]
\- OK [ MARKER ]
\- ERROR HEADER { CHUNK(STRING) } [ MARKER ]
\f[R]
.fi
.PP
Configuration options:
.IP
.nf
\f[C]
user_password <password\-string>
fpc_max_lifetime <duration> [ <duration> [...]]
\f[R]
.fi
.SH AUTHORS
Vadim Sytnikov.
