.\" Automatically generated by Pandoc 2.5
.\"
.ad l
.TH "cybercache" "5" "October 29, 2021" "Copyright (C) 2019 CyberHULL" "CyberCache CE 1.3.6 Low-Level Protocol"
.hy
.SH CyberCache Cluster: Binary Client/Server Protocol Format
.PP
The protocol is binary and can transfer integers, strings, and lists of strings, as well as chunks of binary data.
If it is necessary to pass anything other than an integer number (up to 32 bits, signed or unsigned) or a string, it is passed as a string and client or server (whoever is the recepient) then parses it.
See notes below on 64\-bit extensions.
.RS
.PP
\f[B]NOTE\f[R]: this document describes low\-level protocol details \[en] building blocks from which high\-level commands are assembled.
Command IDs, as well as information on which building blocks comprise which command, can be found in the Command Interface reference manual; please see \f[C]cybercache(1)\f[R].
.RE
.PP
The protocol is designed to cover all Magento 2 session store and cache back\-end needs in the most efficient way; specifically, so that:
.IP \[bu] 2
server could easily separate auxiliary data (only used by worker threads during processing of the request as well as replication/persisting) and permanent data that are to be stored in the cache,
.IP \[bu] 2
server and clients would always receive data of known size, and said size should be computable upon reception of the first fixed, small known number of bytes,
.IP \[bu] 2
server and clients would exchange minimum amounts of data (hence numbers, counts, and lengths are always encoded to only take minimum required space).
.PP
The protocol does not support any kind of \[lq]begin transaction\[rq]/\[lq]end transaction\[rq] commands \[en] but that is because its individual commands are designed in such a way that, what would be accomplished using a transaction in, say, Redis working as Magento session store, is accomplished with a single command of CyberCache protocol.
In other words, its individual commands \f[B]are\f[R] transactions, automatically taking care of cache data integrity.
It is essentially a high\- level protocol specifically tailored for Magento 2 needs, but it can also be utilized by any PHP session store, or by frameworks using Zend cache API.
.SS Requests to Server
.PP
This section describes data sent to the server.
.SS First Chunk: Command Descriptor (\f[C]DESCRIPTOR\f[R])
.PP
Single byte, always present:
.IP \[bu] 2
bits 0 and 1: authentication type
.RS 2
.IP \[bu] 2
00: no authentication
.IP \[bu] 2
01: user\-level authentication
.IP \[bu] 2
10: admin\-level authentication
.IP \[bu] 2
11: bulk authentication (e.g.\ during replication or loading from binlog)
.RE
.IP \[bu] 2
bits 2 and 3: header size
.RS 2
.IP \[bu] 2
00: no header size (only ID and password can be present)
.IP \[bu] 2
01: header size is one byte
.IP \[bu] 2
10: header size is a 16\-bit word
.IP \[bu] 2
11: header size is a 32\-bit word
.RE
.IP \[bu] 2
bits 4 and 5: payload chunk size
.RS 2
.IP \[bu] 2
00: no payload chunk
.IP \[bu] 2
01: [un]compressed payload chunk, sizes are bytes
.IP \[bu] 2
10: [un]compressed payload chunk, sizes are 16\-bit words
.IP \[bu] 2
11: [un]compressed payload chunk, sizes are 32\-bit words
.RE
.IP \[bu] 2
bit 6: compressed (1) or uncompressed (0) payload
.IP \[bu] 2
bit 7: marker byte \f[C]0xC3\f[R] present (1) or absent (0) at the very end of the command
.SS Second Chunk: Command Header (\f[C]HEADER\f[R])
.PP
Header data is only kept until the command is fully processed (executed and optionally replicated and/or persisted); it is referred to in the external documentation as
.IP
.nf
\f[C]
\[ga]HEADER { <ID> [PASSWORD] [PAYLOAD_INFO] <chunk> [ <chunk> [...]] }\[ga]
\f[R]
.fi
.RS
.PP
\f[B]IMPORTANT\f[R]: if a command does not have either a sequence of data chunks (see below) or payload (i.e.\ it only consists of mandatory command ID and optional password hash code) then header size is \f[I]not\f[R] stored in the header, and full command length is then determined by descriptor analysis.
Even though it would also be possible to fully determine header length if payload compression information was stored without header size byte(s) in case of absense of the sequence of data chunks, it\[cq]s been desided not to do that: the payload is likely to be big, so trading a bit of extra convenience for one byte saving did not look worthwhile.
.RE
.PP
Header consists of the following:
.IP \[bu] 2
header size (present if header size in Command Descriptor is not \f[C]00\f[R]):
.RS 2
.IP \[bu] 2
byte if header size bits in Command Descriptor are \f[C]01\f[R]
.IP \[bu] 2
16\-bit word if header size bits in Command Descriptor are \f[C]10\f[R]
.IP \[bu] 2
32\-bit word if header size bits in Command Descriptor are \f[C]11\f[R]
.RE
.IP \[bu] 2
command ID:
.RS 2
.IP \[bu] 2
single byte, always present
.RE
.IP \[bu] 2
password hash code (present if authentication type bits in Command Descriptor are not \f[C]00\f[R]):
.RS 2
.IP \[bu] 2
eigth bytes: password hash code XOR\-ed with a constant
.RE
.IP \[bu] 2
compressor type byte (present if \[lq]compressed payload\[rq] bit in descriptor is \f[C]1\f[R]):
.RS 2
.IP \[bu] 2
0x00: none
.IP \[bu] 2
0x01: lzf
.IP \[bu] 2
0x02: snappy
.IP \[bu] 2
0x03: lz4
.IP \[bu] 2
0x04: lzss3
.IP \[bu] 2
0x05: brotli
.IP \[bu] 2
0x06: zstd
.IP \[bu] 2
0x07: zlib
.IP \[bu] 2
0x08: lzham
.RE
.IP \[bu] 2
payload size (present if payload chunk size is not \f[C]0x00\f[R]):
.RS 2
.IP \[bu] 2
byte if payload chunk size bits in Command Descriptor are \f[C]01\f[R]
.IP \[bu] 2
16\-bit word if payload chunk size bits in Command Descriptor are \f[C]10\f[R]
.IP \[bu] 2
32\-bit word if payload chunk size bits in Command Descriptor are \f[C]11\f[R]
.RE
.IP \[bu] 2
uncompressed payload size (present if \[lq]compressed payload\[rq] bit in descriptor is \f[C]1\f[R]):
.RS 2
.IP \[bu] 2
byte if payload chunk size bits in Command Descriptor are \f[C]01\f[R]
.IP \[bu] 2
16\-bit word if payload chunk size bits in Command Descriptor are \f[C]10\f[R]
.IP \[bu] 2
32\-bit word if payload chunk size bits in Command Descriptor are \f[C]11\f[R]
.RE
.IP \[bu] 2
sequence of data chunks; each starts with data type descriptor byte, high bits define chunk type:
.RS 2
.IP \[bu] 2
00: chunk is an integer number, value bias is lower 6 bits (value is \f[C]8..71\f[R])
.IP \[bu] 2
01: chunk is a string, length bias is lower 6 bits (length is \f[C]8..71\f[R]):
.RS 2
.IP \[bu] 2
next 8..71 bytes: string characters
.RE
.IP \[bu] 2
10: chunk is a list of strings, element count bias in lower 6 bits (element count \f[C]8..71\f[R]); strings are in VLQ format:
.RS 2
.IP \[bu] 2
\f[I]byte\f[R]: element length; if it is \f[C]255\f[R], then length is \f[C]255+<next\-byte>\f[R] IF \f[C]<next\-byte>\f[R] is less than 255 (retrieval of bytes continues until byte less than 255 is found); number of bytes needed for encoding is \f[C]<string\-length>/255+1\f[R]; this format had been chosen over \[lq]classic\[rq] VLQ because, given the protocol\[cq]s intended use, it is much more likely to see a string of length \f[C]128..254\f[R] than of length greater than \f[C]254\f[R]
.IP \[bu] 2
\f[I]next \f[CI]<length>\f[I] bytes\f[R]: element data (string characters, terminating \f[C]0\f[R] is \f[I]not\f[R] stored)
.RE
.IP \[bu] 2
11: chunk is a so\-called \f[I]special value\f[R], type is defined by next 3 bits:
.RS 2
.IP \[bu] 2
000: negative integer value \f[C]\-1..\-8\f[R]; that is, \f[C]minus (lower bits plus one)\f[R]
.IP \[bu] 2
001: negative integer value \f[C]\-9...\f[R], number of extra bytes specified by lower 3 bits plus 1
.IP \[bu] 2
010: small integer value \f[C]0..7\f[R], value is lower 3 bits
.IP \[bu] 2
011: short string of length \f[C]0..7\f[R], length is lower 3 bits
.IP \[bu] 2
100: short list with \f[C]0..7\f[R] elements, count is lower 3 bits; strings in VLQ format
.IP \[bu] 2
101: big positive integer value \f[C]72...\f[R], number of extra bytes specified by lower 3 bits plus 1
.IP \[bu] 2
110: long string of length \f[C]72...\f[R], number of extra bytes specified by lower 3 bits plus 1
.IP \[bu] 2
111: long list with \f[C]72...\f[R] elements, number of extra bytes specified by lower 3 bits plus 1, strings are in VLQ format
.RE
.RE
.PP
Even though big integers (both positive and negative) and long strings and lists have extra data of length that is encoded with three bits, only two of those bits are currently used.
As a result, signed and unsigned integers larger than 32\-bit \f[I]would\f[R] have to be encoded as strings if they were ever needed (the high\-level server protocol does \f[I]not\f[R] currently require transfer of any 64\-bit integers as separate entities).
This restriction may be lifted in the future if the need to send/receive bigger\-than\-32 integers arises.
.PP
If header is followed by bytes of extra data, the data is referred to in the external documentation as \f[C]CHUNK(<type>)\f[R], where \f[C]type\f[R] is one of the following:
.IP \[bu] 2
\f[C]NUMBER\f[R]: chunk descriptor, optional 1..4 extra bytes specifying bias of a positive or negative integer,
.IP \[bu] 2
\f[C]STRING\f[R]: optional 1..4 bytes specifying string length bias, followed by string characters,
.IP \[bu] 2
\f[C]LIST\f[R]: optional 1..4 bytes specifying list count bias, followed by list elements,
.SS Third Chunk: Payload (\f[C]PAYLOAD\f[R])
.PP
Present if payload chunk size bits in Command Descriptor are not \f[C]00\f[R]:
.IP \[bu] 2
compressed data (\f[C]<payload\-size>\f[R] bytes)
.SS Fourth Chunk: Integrity Check (\f[C]MARKER\f[R])
.PP
Present if \[lq]marker byte present\[rq] bit in Command Descriptor is \f[C]1\f[R]: byte \f[C]0xC3\f[R]
.SS Server Responses
.PP
Throughout external documents, the four types of responses (respective descriptors) are denoted as \f[C]OK\f[R], \f[C]DATA\f[R] (header in standard format, same for both commands and responses, payload is binary data), \f[C]LIST\f[R] (header in standard format; payload is a list of strings), and \f[C]ERROR\f[R] (the string in the header is an error message).
Consequently, various combinations of the Response Descriptor and optional data are denoted as follows:
.IP \[bu] 2
\f[C]OK [ MARKER ]\f[R]: success, no data (descriptor only),
.IP \[bu] 2
\f[C]ERROR HEADER { CHUNK(STRING) } [ MARKER ]\f[R]: failure, error message is returned,
.IP \[bu] 2
\f[C]DATA [ HEADER { [ PAYLOAD_INFO ] CHUNK(...) ... } ] [ PAYLOAD ] [ MARKER ]\f[R]: success; optional structured data in the header is returned; if there is payload, it contains session of FPC entry data,
.IP \[bu] 2
\f[C]LIST [ HEADER { [ PAYLOAD_INFO ] CHUNK(...) ... } ] [ PAYLOAD ] [ MARKER ]\f[R]: success, optional structured data in the header is returned; if there is payload, it contains a list (number of entries is in the header).
.SS First Chunk: Response Descriptor
.RS
.PP
\f[B]IMPORTANT\f[R]: just as with command header (see above), if response does not have either a sequence of data chunks or a payload, header size is \f[I]not\f[R] stored, and response header then consists of a single descriptor byte.
.RE
.PP
Single byte, always present:
.IP \[bu] 2
bits 0 and 1: response type:
.RS 2
.IP \[bu] 2
00: success, no extra data
.IP \[bu] 2
01: success, payload (if present) is binary data
.IP \[bu] 2
10: success, payload (if present) is list of strings
.IP \[bu] 2
11: error, header contains error message
.RE
.IP \[bu] 2
bits 2 and 3: header size
.RS 2
.IP \[bu] 2
00: no header size (must be an \f[C]OK\f[R] response)
.IP \[bu] 2
01: header size is one byte
.IP \[bu] 2
10: header size is a 16\-bit word
.IP \[bu] 2
11: header size is a 32\-bit word
.RE
.IP \[bu] 2
bits 4 and 5: payload chunk size
.RS 2
.IP \[bu] 2
00: no payload chunk
.IP \[bu] 2
01: [un]compressed payload chunk, sizes are bytes
.IP \[bu] 2
10: [un]compressed payload chunk, sizes are 16\-bit words
.IP \[bu] 2
11: [un]compressed payload chunk, sizes are 32\-bit words
.RE
.IP \[bu] 2
bit 6: compressed (1) or uncompressed (0) payload
.IP \[bu] 2
bit 7: marker byte \f[C]0xC3\f[R] present (1) or absent (0) at the very end of the response
.SS Second Chunk: Response Header
.PP
Consists of the following:
.IP \[bu] 2
header size (present if header size in Response Descriptor is not \f[C]00\f[R]):
.RS 2
.IP \[bu] 2
byte if header size bits in Response Descriptor are \f[C]01\f[R]
.IP \[bu] 2
16\-bit word if header size bits in Response Descriptor are \f[C]10\f[R]
.IP \[bu] 2
32\-bit word if header size bits in Response Descriptor are \f[C]11\f[R]
.RE
.IP \[bu] 2
compressor type byte (present if \[lq]compressed payload\[rq] bit in descriptor is \f[C]1\f[R]):
.RS 2
.IP \[bu] 2
0x00: none
.IP \[bu] 2
0x01: lzf
.IP \[bu] 2
0x02: snappy
.IP \[bu] 2
0x03: lz4
.IP \[bu] 2
0x04: lzss3
.IP \[bu] 2
0x05: brotli
.IP \[bu] 2
0x06: zstd
.IP \[bu] 2
0x07: zlib
.IP \[bu] 2
0x08: lzham
.RE
.IP \[bu] 2
payload size (present if payload chunk size is not \f[C]0x00\f[R]):
.RS 2
.IP \[bu] 2
byte if payload chunk size bits in Response Descriptor are \f[C]01\f[R]
.IP \[bu] 2
16\-bit word if payload chunk size bits in Response Descriptor are \f[C]10\f[R]
.IP \[bu] 2
32\-bit word if payload chunk size bits in Response Descriptor are \f[C]11\f[R]
.RE
.IP \[bu] 2
uncompressed payload size (present if \[lq]compressed payload\[rq] bit in descriptor is \f[C]1\f[R]):
.RS 2
.IP \[bu] 2
byte if payload chunk size bits in Response Descriptor are \f[C]01\f[R]
.IP \[bu] 2
16\-bit word if payload chunk size bits in Response Descriptor are \f[C]10\f[R]
.IP \[bu] 2
32\-bit word if payload chunk size bits in Response Descriptor are \f[C]11\f[R]
.RE
.IP \[bu] 2
sequence of data chunks; format of the chunks is the same as that used in the Command Header (see above).
.SS Third Chunk: Payload (\f[C]PAYLOAD\f[R])
.PP
Present if payload chunk size bits in Command Descriptor are not \f[C]00\f[R]:
.IP \[bu] 2
compressed data (\f[C]<payload\-size>\f[R] bytes)
.SS Fourth Chunk: Integrity Check (\f[C]MARKER\f[R])
.PP
Present if \[lq]marker byte present\[rq] bit in Response Descriptor is \f[C]1\f[R]: byte \f[C]0xC3\f[R]
.SH AUTHORS
Vadim Sytnikov.
