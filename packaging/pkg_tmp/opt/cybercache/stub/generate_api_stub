#! /usr/bin/php
<?php
/*
 * This file is a part of the implementation of the CyberCache Cluster.
 * Written by Vadim Sytnikov.
 * Copyright (C) 2016-2019 CyberHULL. All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 */

const PROGRESS_VERBOSITY = 0; // 0: only errors and result, 1: constants and functions, 2: function arguments

echo <<< BANNER_MESSAGE
PHP extension API stub generator.
Written by Vadim Sytnikov.
Copyright (C) 2019 CyberHULL.

BANNER_MESSAGE;

function fail($message) {
  echo "ERROR: $message\n";
  exit(3);
}

// 1) If two file names are not specified, print out usage info and quit
// ---------------------------------------------------------------------

if ($argc != 3) {
  echo <<< HELP_MESSAGE
Generates API stub given the output of a module information command
like `php --re cybercache`. Usage:

  generate_api_stub <input-module-info-file> <output-stub-file>

HELP_MESSAGE;
  exit(1);
}

// 2) Load input file
// ------------------

$input_path = $argv[1];
$input_text = @file_get_contents($input_path);
if (!$input_text) {
  fail("could not load '$input_path'");
}

echo "Loaded '$input_path'.\n";

// 3) Parse constants (for now, only integer constants are supported)
// ------------------------------------------------------------------

$constants = [];
// Constant [ integer C3_DOMAIN_GLOBAL ] { 1 }
$nconstants = preg_match_all('/Constant\s+\[\s+(integer)\s+([A-Z\d_]+)\s+\]\s+\{\s+(\d+)\s+\}/',
  $input_text, $matches, PREG_SET_ORDER);
if ($nconstants) {
  echo "Extracted $nconstants constants\n";
  for ($i = 0; $i < $nconstants; $i++) {
    $match = &$matches[$i];
    $name = $match[2];
    $value = $match[3];
    if (PROGRESS_VERBOSITY >= 1) {
      echo "$i) '$name' = $value\n";
    }
    $constants[$name] = $value;
  }
} else {
  fail("could not extract constants");
}

// 4) Parse functions
// ------------------

$functions = [];
// Function [ <internal:cybercache> function c3_session ] {
//   - Parameters [1] {
//     Parameter #0 [ <required> $resource ]
$nfunctions = preg_match_all('/Function\s+\[\s+<[^>]+>\s+function\s+([a-z\d_]+)\s+\]\s+\{\s+-\s+Parameters\s+\[(\d+)\]\s+\{([^}]+)\}/U',
  $input_text, $matches, PREG_SET_ORDER);
if ($nfunctions) {
  echo "Extracted $nfunctions functions\n";
  for ($i = 0; $i < $nfunctions; $i++) {
    $match = &$matches[$i];
    $name = $match[1];
    $nparams = $match[2];
    $params = $match[3];
    if (PROGRESS_VERBOSITY >= 1) {
      echo "$i) '$name' ($nparams arguments)\n";
    }
    // 4A) Extract function arguments
    $args = [];
    $nargs = preg_match_all('/Parameter\s+#\d+\s+\[\s+<(required|optional)>\s+(array( or NULL)?)?\s*(\.\.\.)?([$a-z\d_]+)\s+\]/U',
      $params, $pmatches, PREG_SET_ORDER);
    if ($nargs != $nparams) {
      fail("could not extract function arguments ($nargs/$nparams)");
    }
    for ($j = 0; $j < $nargs; $j++) {
      $pmatch = &$pmatches[$j];
      $arg = [];
      $arg['optional'] = $pmatch[1] == 'optional';
      $arg['array'] = !empty($pmatch[2]);
      $arg['nullable'] = !empty($pmatch[3]);
      $arg['variadic'] = !empty($pmatch[4]);
      $arg['name'] = $pmatch[5];
      $args[] = $arg;
      if (PROGRESS_VERBOSITY >= 2) {
        echo "  $j) '$pmatch[5]'\n";
      }
    }
    $functions[$name] = $args;
  }
} else {
  fail("could not extract functions");
}

// 5) Compose stub header
// ----------------------

$output_text = <<< STUB_HEADER
<?php
/**
 * CyberCache Cluster PHP API definition:
 *   constants and functions exported by `cybercache` PHP extension.
 * Automatically generated by `generate_api_stub` utility by Vadim Sytnikov.
 * Copyright (C) 2019 CyberHULL.
 *
 * The API was architected to match Zend/Magento conventions as closely as possible, so that translation
 * layer in PHP code would be absolutely minimal. For instance, `c3_get_metadatas()` returns `false` (and
 * not an empty array) because that is what `Zend_Cache_Backend_ExtendedInterface::getMetadatas()` does.
 */

STUB_HEADER;

// 6) Generate constants' definitions
// ----------------------------------

$c_desc = [
  'C3_DOMAIN_GLOBAL'  => 'Global domain ID (denotes what does not pertain to a session or FPC store)',
  'C3_DOMAIN_SESSION' => 'ID of the session store',
  'C3_DOMAIN_FPC'     => 'ID of the FPC (full page cache) store',
  'C3_DOMAIN_ALL'     => 'Comination of all domain IDs supported by the cache',
  'C3_UA_UNKNOWN'     => 'User agent type: an unknown user',
  'C3_UA_BOT'         => 'User agent type: a known bot',
  'C3_UA_WARMER'      => 'User agent type: CyberHULL cache warmer',
  'C3_UA_USER'        => 'User agent type: a regular user',
  'C3_SYNC_NONE'      => 'Synchronization mode: none (fully buffered); fastest but least reliable',
  'C3_SYNC_DATA_ONLY' => 'Synchronization mode: everything except file/directory meta-data',
  'C3_SYNC_FULL'      => 'Synchronization mode: complete; most reliable but slowest'
];
foreach ($constants as $name => $value) {
  if (array_key_exists($name, $c_desc)) {
    $desc = $c_desc[$name];
    $output_text .= <<< STUB_CONST

/**
 * $desc.
 *
 * An integer. See man entry cybercache(1) for more information.
 */
define('$name', $value);

STUB_CONST;
  } else {
    fail("cannot find description of constant '$name'");
  }
}

// 7) Generate function definitions
// --------------------------------

$f_desc = [
  'c3_session' => ['Creates session resource; does NOT connect to the server', 'resource Handle of the resource to manage session store'],
  'c3_read' => ['Loads specified session record', 'string Session record data on success, empty string if record does not exist'],
  'c3_write' => ['Saves specified session record', 'boolean `true` on success, `false` on error'],
  'c3_destroy' => ['Deletes specified session record', 'boolean `true` on success (or if record did not exist), `false` on error'],
  'c3_gc' => ['Performs garbage collection in session store', 'boolean `true` on success, `false` on errors'],
  'c3_fpc' => ['Creates FPC (full page cache) resource; does NOT connect to the server', 'resource Handle of the resource to manage FPC store'],
  'c3_load' => ['Loads specified FPC record', 'string FPC record data on success, empty string if record does not exist'],
  'c3_test' => ['Checks whether specified FPC record exists', 'mixed Integer last modification timestamp of the record, or `false` if the record does not exist'],
  'c3_save' => ['Saves specified FPC record', 'boolean `true` on success, `false` on error'],
  'c3_remove' => ['Deletes specified FPC record', 'boolean `true` on success (or if record did not exist), `false` on error'],
  'c3_clean' => ['Deletes specified FPC records', 'boolean `true` on success, `false` on errors'],
  'c3_get_ids' => ['Retrieves list of IDs of all records in FPC store', 'array Array of strings on success, empty array otherwise'],
  'c3_get_tags' => ['Retrieves list of IDs of all tags in FPC store', 'array Array of strings on success, empty array otherwise'],
  'c3_get_ids_matching_tags' => ['Retrieves list of IDs of FPC records marked with all specified tags', 'array Array of strings on success, empty array otherwise'],
  'c3_get_ids_not_matching_tags' => ['Retrieves list of IDs of FPC records not marked with any of the specified tags', 'array Array of strings on success, empty array otherwise'],
  'c3_get_ids_matching_any_tags' => ['Retrieves list of IDs of FPC records marked with any of the specified tags', 'array Array of strings on success, empty array otherwise'],
  'c3_get_filling_percentage' => ['Returns current filling percentage of the FPC store', 'integer Number in 0..100 range; on errors, returns 0'],
  'c3_get_metadatas' => ['Fetches metadata of the specified record', 'mixed Array with `expire`, `mtime`, and `tags` keys on success, `false` otherwise'],
  'c3_touch' => ['Adds specified number of seconds to the lifetime of the record with given ID', 'boolean `true` on success, `false` otherwise'],
  'c3_get_capabilities' => ['Returns array with capabilities of the cache backend', 'array Array with `automatic_cleaning`, `tags`, `expired_read`, `priority`, `infinite_lifetime`, and `get_list` keys'],
  'c3_ping' => ['Sends `PING` command to the server', 'boolean `true` on success, `false` on error'],
  'c3_check' => ['Sends `CHECK` command to the server`', 'array Array with three `int`s on success, empty array on errors'],
  'c3_info' => ['Retrieves information on specified (set of) domain(s)', 'array Array with info strings on success, empty array on errors'],
  'c3_stats' => ['Retrieves performance counters for specified domain(s) matching mask; requires instrumented server', 'array Array with performance info strings on success, empty array on errors'],
  'c3_shutdown' => ['Initiates server shutdown procedure', 'boolean `true` on success, `false` on errors'],
  'c3_local_config' => ['Loads local configuration file and sends it to the server', 'boolean `true` on success, `false` on errors'],
  'c3_remote_config' => ['Instructs server to load remote configuration file', 'boolean `true` on success, `false` on errors'],
  'c3_restore' => ['Instructs server to load and play back binlog file', 'boolean `true` on success, `false` on errors'],
  'c3_store' => ['Stores specified cache records into database file', 'boolean `true` on success, `false` on errors'],
  'c3_get' => ['Fetches current value of server configuration option(s)', 'array Array of string values on success, empty array on errors'],
  'c3_set' => ['Sets server configuration option to a new value', 'boolean `true` on success, `false` on errors'],
  'c3_log' => ['Instructs server to log provided string to its log file', 'boolean `true` on success, `false` on errors'],
  'c3_rotate' => ['Forces log or binlog rotation', 'boolean `true` on success, `false` on errors'],
  'c3_get_last_error' => ['Fetches last error message returned by the server, if any', 'string String with error message, empty string is there was no error']
];

$p_desc = [
  '$resource' => ['resource', 'CyberCache resource handle returned by `c3_session()` or `c3_fpc()` call'],
  '$options' => ['array', 'Array with one or more of the following keys: `user`, `admin`, `address`, `port`, `marker`, `hasher`; all values MUST be strings'],
  '$id' => ['string', 'Cache record ID'],
  '$request_id' => ['integer', 'Request ID; 0 disables session locking/unlocking, -1 forces use of "real" request ID'],
  '$data' => ['string', 'Data to be stored in the cache store record'],
  '$seconds' => ['integer', 'How many seconds the record was not updated (to be eligible for purging)'],
  '$lifetime' => ['integer', 'Record lifetime, seconds; 0 mean infinite, -1 means use value specified in configuration file'],
  '$tags' => ['array', 'List of tags specified as a regular array'],
  '$mode' => ['string', 'Cleaning mode; one of the following: `all`, `old`, `matchingTag`, `notMatchingTag`, `matchingAnyTag`'],
  '$extra_lifetime' => ['integer', 'Number of seconds to add to the lifetime of a cache record'],
  '$domain' => ['integer', 'Specifies to which subsystem(s) the command applies; a combination of `C3_DOMAIN_xxx` constants'],
  '$user_agent' => ['integer', 'Specifies "least important" user agent whose records to include; a `C3_UA_xxx` constant'],
  '$sync_mode' => ['integer', 'What synchronization mode to use for writing files; a `C3_SYNC_xxx` constant'],
  '$path' => ['string', 'Linux file path; please see documentation as to how exactly it is interpreted'],
  '$name_mask' => ['string', 'Mask of names of performance counters whose values are to be retrieved'],
  '$option_names' => ['string', 'Masks of names of the server options whose values are to be retrieved'],
  '$option_name' => ['string', 'Name of the server option whose value is to be set'],
  '$option_value' => ['string', 'New value of the server option'],
  '$message' => ['string', 'Message to write to the server log file']
];
$p_defaults = [
  'c3_clean' => 'NULL',
  'c3_info' => 'C3_DOMAIN_ALL',
  'c3_stats' => [
    '$domain' => 'C3_DOMAIN_ALL',
    '$name_mask' => '"*"'
  ],
  'c3_rotate' => 'C3_DOMAIN_GLOBAL',
  'c3_store' => [
    '$user_agent' => 'C3_UA_UNKNOWN',
    '$sync_mode' => 'C3_SYNC_NONE'
  ],
  'c3_read' => '-1',
  'c3_write' => '-1'
];

foreach ($functions as $name => $args) {
  if (array_key_exists($name, $f_desc)) {
    list($desc, $r_desc) = $f_desc[$name];
    // process arguments
    $a_formal = '';
    if ($args) {
      $a_info = '';
      $a_info_sep = '';
      $a_formal_sep = '';
      foreach ($args as $arg) {
        // get parameter info
        $a_name = $arg['name'];
        $a_optional = $arg['optional'];
        $a_array = $arg['array'];
        $a_nullable = $arg['nullable'];
        $a_variadic = $arg['variadic'];
        if (array_key_exists($a_name, $p_desc)) {
          list($a_type, $a_desc) = $p_desc[$a_name];
          if ($a_array && $a_type != 'array') {
            fail("type mismatch for parameter '$a_name' for $name()");
          }
        } else {
          fail("cannot find description of parameter '$a_name' for $name()");
        }
        // figure out default value, if any
        if ($a_optional) {
          if ($a_nullable) {
            $a_default_value = 'NULL';
          } else {
            if (array_key_exists($name, $p_defaults)) {
              $a_default_value = $p_defaults[$name];
              if (is_array($a_default_value)) {
                if (array_key_exists($a_name, $a_default_value)) {
                  $a_default_value = $a_default_value[$a_name];
                } else {
                  fail("could not fetch default value of parameter '$a_name' for $name()");
                }
              }
            } else {
              fail("could not infer default value of parameter '$a_name' for $name()");
            }
          }
          $a_desc_default = " Optional; default value is $a_default_value.";
          $a_formal_default = " = $a_default_value";
        } else {
          $a_desc_default = '';
          $a_formal_default = '';
        }
        // handle variadic functions
        if ($a_variadic) {
          $a_desc_var = ' One or more values can be specified.';
          $a_formal_var = '...';
        } else {
          $a_desc_var = '';
          $a_formal_var = '';
        }
        // process type hints
        $a_hint = '';
        switch ($a_type) {
          case 'array':
            $a_hint = 'array ';
            break;
          case 'string':
            $a_hint = 'string ';
            break;
          case 'boolean':
            $a_hint = 'bool ';
            break;
          case 'integer':
            $a_hint = 'int ';
            break;
        }
        // compile parameter description
        $a_info .= $a_info_sep . " * @param $a_type $a_name $a_desc.$a_desc_default$a_desc_var";
        $a_formal .= $a_formal_sep . $a_hint . $a_formal_var . $a_name . $a_formal_default;
        $a_info_sep = "\n";
        $a_formal_sep = ', ';
      }
    } else {
      $a_info = ' * This method does not take any arguments.';
    }
    $output_text .= <<< STUB_FUNCTION

/**
 * $desc.
 *
 * See man entry cybercache(1) for more information.
 *
$a_info
 *
 * @return $r_desc.
 */
function $name($a_formal) {}

STUB_FUNCTION;
  } else {
    fail("cannot find description of function '$name'");
  }
}

// 8) Write down stub file
// -----------------------

$output_path = $argv[2];
if (file_put_contents($output_path, $output_text)) {
  echo "Successfully saved PHP API stub '$output_path'\n";
} else {
  fail("could not save '$output_path'");
}
